{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"erdantic: Entity Relationship Diagrams","text":"<p>Note</p> <p>erdantic v1.0 is coming soon and involves big backend changes. See the changelog for more information.</p> <p>erdantic is a simple tool for drawing entity relationship diagrams (ERDs) for Python data model classes. Diagrams are rendered using the venerable Graphviz library. Supported data modeling frameworks are:</p> <ul> <li>Pydantic V2</li> <li>Pydantic V1 legacy</li> <li>attrs</li> <li>dataclasses from the Python standard library</li> </ul> <p>You can use erdantic either as a convenient CLI or as a Python library. Great for adding a simple and clean data model reference to your documentation.</p>"},{"location":"#installation","title":"Installation","text":"<p>erdantic's graph modeling depends on pygraphviz and Graphviz, an open-source C library. If you are on Linux or macOS, the easiest way to install everything together is to use conda and conda-forge:</p> <pre><code>conda install erdantic -c conda-forge\n</code></pre> <p>If not using conda, Graphviz must be installed first (before you can install pygraphviz). For recommended options and installation troubleshooting, see the pygraphviz docs. Then to install erdantic and its Python dependencies from PyPI:</p> <pre><code>pip install erdantic\n</code></pre>"},{"location":"#development-version","title":"Development version","text":"<p>You can get the development version from GitHub with:</p> <pre><code>pip install git+https://github.com/drivendataorg/erdantic.git#egg=erdantic\n</code></pre>"},{"location":"#quick-usage","title":"Quick usage","text":"<p>First, make sure that the data model classes that you want to include in your diagram are importable. This means the code with your models should either be available on your <code>sys.path</code> or installed into the same virtual environment as erdantic.</p> <p>The fastest way to produce a diagram like the above example is to use the erdantic CLI. Simply specify the full dotted import path to your model and an output file path. The rendered format is interpreted from the filename extension.</p> <pre><code>erdantic erdantic.examples.pydantic.Party -o diagram.png\n</code></pre> <p>You can also import the erdantic Python library. This lets you inspect the diagram data and potentially modify it. You will have greater ability to customize the diagram in Python.</p> <pre><code>import erdantic as erd\nfrom erdantic.examples.pydantic import Party\n\n# Easy one-liner\nerd.draw(Party, out=\"diagram.png\")\n\n# Or create a diagram object that you can inspect and do stuff with\ndiagram = erd.create(Party)\nlist(diagram.models.keys())\n#&gt; [ 'erdantic.examples.pydantic.Adventurer',\n#&gt;   'erdantic.examples.pydantic.Party',\n#&gt;   'erdantic.examples.pydantic.Quest',\n#&gt;   'erdantic.examples.pydantic.QuestGiver']\ndiagram.draw(\"diagram.png\")\n</code></pre> <p>Check out the \"Usage Examples\" section of our docs to see more.</p>"},{"location":"changelog/","title":"erdantic Changelog","text":""},{"location":"changelog/#v100rc1-release-candidate-2024-03-30","title":"v1.0.0rc1 Release Candidate (2024-03-30)","text":"<p>This is a pre-release version for v1.0.0.</p> <p>Important</p> <p>This release features significant changes to erdantic, primarily to the backend process of analyzing models and representing data. If you have been primarily using the CLI or the convenience functions <code>create</code>, <code>draw</code>, and <code>to_dot</code>, then your code may continue to work without any changes. If you are doing something more advanced, you may need to update your code.</p>"},{"location":"changelog/#cli-changes","title":"CLI changes","text":"<ul> <li>Deprecated <code>--termini</code> option. Use the new <code>--terminal-model</code> option instead. The shorthand option <code>-t</code> remains the same. The <code>--termini</code> option still works but will emit a deprecation warning.</li> </ul>"},{"location":"changelog/#convenience-function-changes","title":"Convenience function changes","text":"<ul> <li>Deprecated <code>termini</code> argument for <code>create</code>, <code>draw</code>, and <code>to_dot</code> functions. Use the new <code>terminal_models</code> argument instead. The <code>termini</code> argument still works but will emit a deprecation warning.</li> <li>Added <code>graph_attr</code>, <code>node_attr</code>, and <code>edge_attr</code> arguments to the <code>draw</code> and <code>to_dot</code> functions that allow you to override attributes on the generated pygraphviz object for the diagram.</li> </ul>"},{"location":"changelog/#visual-changes","title":"Visual changes","text":"<p>A few changes have been made to the visual content of rendered diagrams.</p> <ul> <li>Changed the extraction of type names to use the typenames library. This should generally produce identical rendered outputs as before, with the following exception:<ul> <li>Removed the special case behavior for rendering enum classes. Enums now just show the class name without inheritance information.</li> </ul> </li> <li>Changed collection fields (e.g., <code>List[TargetModel]</code>) to display as a \"many\" relationship (crow) instead of a \"zero-or-many\" relationship (odot + crow), treating the modality of the field as unspecified. A field will only be displayed as \"zero-or-many\" (odot + crow) if it is explicitly optional, like <code>Optional[List[TargetModel]]</code>.</li> <li>Fixed incorrect representation of manyness for type annotations where the outermost annotation wasn't a collection type. (Issue #105)</li> </ul>"},{"location":"changelog/#support-for-attrs","title":"Support for attrs","text":"<ul> <li>Added support for attrs classes, i.e., classes decorated by <code>attrs.define</code>. The source code for attrs support can be found in the new module <code>erdantic.plugins.attrs</code>.</li> <li>Added new example module <code>erdantic.examples.attrs</code>.</li> </ul>"},{"location":"changelog/#backend-changes","title":"Backend changes","text":"<p>Significant changes have been made to the library backend to more strongly separate the model analysis process, the extracted data, and the diagram rendering process. We believe this more structured design facilitates customizing diagrams and simplifies the implementation for each data modeling framework. Please see the new documentation pages \"Customizing diagrams\" and \"Extending or modifying erdantic\" for details on the new design.</p> <p>A summary of some key changes is below:</p> <ul> <li>Removed the adapter base classes <code>Model</code> and <code>Field</code> and the conrete adapters <code>DataClassModel</code>, <code>DataClassField</code>, <code>PydanticModel</code>, and <code>PydanticField</code>.</li> <li>Added new Pydantic models <code>ModelInfo</code> and <code>FieldInfo</code> to replace the adapter system. These new models hold static data that have been extracted from models that erdantic analyzed.</li> <li>Removed the adapter system and associated objects such as <code>model_adapter_registry</code> and <code>register_model_adapter</code>.</li> <li>Added new plugin system to replace the adapter system as the way that modeling frameworks are supported. Plugins must implement two functions\u2014a predicate function and a field extractor function\u2014and be registered using <code>register_plugin</code>. All objects related to plugins can be found in the new <code>erdantic.plugins</code> module and its submodules.</li> <li>Renamed <code>erdantic.typing</code> module to <code>erdantic.typing_utils</code>.</li> </ul>"},{"location":"changelog/#other","title":"Other","text":"<ul> <li>Added PEP 561 <code>py.typed</code> marker file to indicate that the package supports type checking.</li> <li>Added IPython special method for pretty-print string representations of <code>EntityRelationshipDiagram</code> instances.</li> <li>Removed support for Python 3.7. (PR #102)</li> </ul>"},{"location":"changelog/#v070-2024-02-11","title":"v0.7.0 (2024-02-11)","text":"<p>This will be the last version that supports Python 3.7.</p> <ul> <li>Added support for Pydantic V1 legacy models. These are models created from the <code>pydantic.v1</code> namespace when Pydantic V2 is installed. (PR #94 from @ursereg)</li> </ul>"},{"location":"changelog/#v060-2023-07-09","title":"v0.6.0 (2023-07-09)","text":"<ul> <li>Added support for Pydantic V2.</li> <li>Removed support for Pydantic V1.</li> <li>Changed the init signature for <code>PydanticField</code> to work with Pydantic V2's API.</li> <li>Added <code>is_many</code> and <code>is_nullable</code> functions to <code>erdantic.typing</code>.</li> </ul>"},{"location":"changelog/#v051-2023-07-04","title":"v0.5.1 (2023-07-04)","text":"<ul> <li>Changed Pydantic dependency to be <code>&lt; 2</code>. This will be the final version of erdantic that supports Pydantic V1.</li> <li>Changed to pyproject.toml-based build.</li> </ul>"},{"location":"changelog/#v050-2022-07-29","title":"v0.5.0 (2022-07-29)","text":"<ul> <li>Removed support for Python 3.6. (Issue #51, PR #56)</li> <li>Added support for modules as inputs to all entrypoints to diagram creation (<code>create</code>, <code>draw</code>, <code>to_dot</code>, CLI). For all modules passed, erdantic will find all supported data model classes in each module. (Issue #23, PR #58)<ul> <li>Added new parameter <code>limit_search_models_to</code> to all entrypoints to allow for limiting which data model classes will be yielded from searching a module.</li> </ul> </li> </ul>"},{"location":"changelog/#v041-2022-04-08","title":"v0.4.1 (2022-04-08)","text":"<ul> <li>Fixed error when rendering a data model that has field using <code>typing.Literal</code>. (PR #49)</li> </ul>"},{"location":"changelog/#v040-2021-11-06","title":"v0.4.0 (2021-11-06)","text":"<ul> <li>Added support for showing field documentation from Pydantic models with descriptions set with <code>Field(description=...)</code> in SVG tooltips. This will add an \"Attributes\" section to the tooltip using Google-style docstring format and lists fields where the <code>description</code> keyword argument is used. (Issue #8, PR #42)</li> </ul>"},{"location":"changelog/#v030-2021-10-28","title":"v0.3.0 (2021-10-28)","text":"<ul> <li>Fixed handling of forward references in field type declarations. Evaluated forward references will be properly identified. Forward references not converted to <code>typing.ForwardRef</code> will throw a <code>StringForwardRefError</code> with instructions for how to resolve. Unevaluated forward references will throw an <code>UnevaluatedForwardRefError</code> with instructions for how to resolve. See new documentation for more details. (Issue #40, PR #41)</li> <li>Changed name of <code>erdantic.errors</code> module to <code>erdantic.exceptions</code>. (PR #41)</li> <li>Added new <code>ErdanticException</code> base class from which other exceptions raised within the erdantic library are subclassed from. Changed several existing <code>ValueError</code> exceptions to new exception classes that subclass both <code>ErdanticException</code> and <code>ValueError</code>. (PR #41)</li> <li>Changed <code>__lt__</code> method on <code>Model</code> and <code>Edge</code> to return <code>NotImplemented</code> instead of raising an exception to follow typical convention for unsupported input types. (PR #41)</li> </ul>"},{"location":"changelog/#v021-2021-02-16","title":"v0.2.1 (2021-02-16)","text":"<ul> <li>Fixed runtime error when rendering a data model that had a field containing <code>typing.Any</code>. (Issue #25, PR #26)</li> </ul>"},{"location":"changelog/#v020-2021-02-14","title":"v0.2.0 (2021-02-14)","text":"<ul> <li>Added option to specify models as terminal nodes. This allows you to truncate large diagrams and split them up into smaller ones. (PR #24)</li> </ul>"},{"location":"changelog/#v012-2021-02-10","title":"v0.1.2 (2021-02-10)","text":"<ul> <li>Fixed bug where Pydantic fields were missing generics in their type annotations. (PR #19)</li> <li>Added tests against static rendered DOT output. Change adapter tests to use parameterized fixtures. (PR #21)</li> </ul>"},{"location":"changelog/#v011-2021-02-10","title":"v0.1.1 (2021-02-10)","text":"<ul> <li>Fixed rendered example image in the package description on PyPI. (PR #18)</li> </ul>"},{"location":"changelog/#v010-2021-02-10","title":"v0.1.0 (2021-02-10)","text":"<p>Initial release! \ud83c\udf89</p>"},{"location":"cli/","title":"CLI help documentation","text":"<p>To view the CLI help documentation, run:</p> <pre><code>erdantic --help\n# or\npython -m erdantic --help\n</code></pre> <pre><code> Usage: erdantic [OPTIONS] MODELS_OR_MODULES...                                 \n\n Draw entity relationship diagrams (ERDs) for Python data model classes.        \n Diagrams are rendered using the Graphviz library. Currently supported data     \n modeling frameworks are Pydantic, attrs, and standard library dataclasses.     \n\n\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *    models_or_modules      MODELS_OR_MODULES...  One or more full dotted    \u2502\n\u2502                                                   paths for data model       \u2502\n\u2502                                                   classes, or modules        \u2502\n\u2502                                                   containing data model      \u2502\n\u2502                                                   classes, to include in     \u2502\n\u2502                                                   diagram, e.g.,             \u2502\n\u2502                                                   'erdantic.examples.pydant\u2026 \u2502\n\u2502                                                   Only the root models of    \u2502\n\u2502                                                   composition trees are      \u2502\n\u2502                                                   needed; erdantic will      \u2502\n\u2502                                                   traverse the composition   \u2502\n\u2502                                                   tree to find component     \u2502\n\u2502                                                   classes.                   \u2502\n\u2502                                                   [default: None]            \u2502\n\u2502                                                   [required]                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --out                 -o      PATH                  Output filename.      \u2502\n\u2502                                                        [default: None]       \u2502\n\u2502                                                        [required]            \u2502\n\u2502    --terminal-model      -t      TEXT                  Full dotted paths for \u2502\n\u2502                                                        data model classes to \u2502\n\u2502                                                        set as terminal nodes \u2502\n\u2502                                                        in the diagram.       \u2502\n\u2502                                                        erdantic will stop    \u2502\n\u2502                                                        searching for         \u2502\n\u2502                                                        component classes     \u2502\n\u2502                                                        when it reaches these \u2502\n\u2502                                                        models. Repeat this   \u2502\n\u2502                                                        option if more than   \u2502\n\u2502                                                        one.                  \u2502\n\u2502    --terminus                    TEXT                  Deprecated. Use       \u2502\n\u2502                                                        --terminal-model      \u2502\n\u2502                                                        instead.              \u2502\n\u2502    --limit-search-mode\u2026  -m      [pydantic|pydantic_v  Plugin identifiers.   \u2502\n\u2502                                  1|attrs|dataclasses]  If any are specified, \u2502\n\u2502                                                        when searching a      \u2502\n\u2502                                                        module, limit data    \u2502\n\u2502                                                        model classes to      \u2502\n\u2502                                                        those ones. Repeat    \u2502\n\u2502                                                        this option if more   \u2502\n\u2502                                                        than one. Defaults to \u2502\n\u2502                                                        None which will find  \u2502\n\u2502                                                        data model classes    \u2502\n\u2502                                                        matching any active   \u2502\n\u2502                                                        plugin.               \u2502\n\u2502    --dot                 -d                            Print out Graphviz    \u2502\n\u2502                                                        DOT language          \u2502\n\u2502                                                        representation for    \u2502\n\u2502                                                        generated graph to    \u2502\n\u2502                                                        console instead of    \u2502\n\u2502                                                        rendering an image.   \u2502\n\u2502                                                        The --out option will \u2502\n\u2502                                                        be ignored.           \u2502\n\u2502    --no-overwrite                                      Prevent overwriting   \u2502\n\u2502                                                        an existing file.     \u2502\n\u2502    --quiet               -q      INTEGER               Use to decrease log   \u2502\n\u2502                                                        verbosity. Can use    \u2502\n\u2502                                                        multiple times.       \u2502\n\u2502    --verbose             -v      INTEGER               Use to increase log   \u2502\n\u2502                                                        verbosity. Can use    \u2502\n\u2502                                                        multiple times.       \u2502\n\u2502    --version                                           Show erdantic version \u2502\n\u2502                                                        and exit.             \u2502\n\u2502    --install-completion                                Install completion    \u2502\n\u2502                                                        for the current       \u2502\n\u2502                                                        shell.                \u2502\n\u2502    --show-completion                                   Show completion for   \u2502\n\u2502                                                        the current shell, to \u2502\n\u2502                                                        copy it or customize  \u2502\n\u2502                                                        the installation.     \u2502\n\u2502    --help                                              Show this message and \u2502\n\u2502                                                        exit.                 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"customizing/","title":"Customizing diagrams","text":"<p>Note</p> <p>Major changes were made to the backend in v1.0 to support the customization capabilities described on this page.</p>"},{"location":"customizing/#customizing-graph-appearance","title":"Customizing graph appearance","text":"<p>erdantic uses the Graphviz program for laying out and rendering the diagram via the PyGraphviz package. When calling the <code>draw</code> function, you have the ability to pass in overrides for Graphviz graph, node, and edge attributes with the following keyword arguments:</p> <ul> <li><code>graph_attr: dict[str, Any]</code> \u2014 key-value pairs of graph attributes. See \"Graph Attributes\" in the Graphviz docs for valid options.</li> <li><code>node_attr: dict[str, Any]</code> \u2014 key-value pairs of node attributes to set on all nodes. See \"Node Attributes\" in the Graphviz docs for valid options.</li> <li><code>edge_attr: dict[str, Any]</code> \u2014 key-value pairs of edge attributes to set on all edges. See \"Edge Attributes\" in the Graphviz docs for valid options.</li> </ul> <p>These will be merged with erdantic's default values (see <code>DEFAULT_GRAPH_ATTR</code>, <code>DEFAULT_GRAPH_ATTR</code>, and <code>DEFAULT_GRAPH_ATTR</code>).</p> <p>Some common attributes you might want to change:</p> <ul> <li><code>graph_attr[\"nodesep\"]: float</code> \u2014 controls vertical spacing between models in diagram.</li> <li><code>graph_attr[\"ranksep\"]: float</code> \u2014 controls horizontal spacing between models in diagram.</li> <li><code>node_attr[\"fontsize\"]: float</code> \u2014 controls font size of text in model tables.</li> </ul>"},{"location":"customizing/#customizing-diagram-content","title":"Customizing diagram content","text":"<p>Behind the scenes, all of the information that erdantic extracts from data model classes is stored as data on Pydantic models. Because everything is represented as just data, you can do any of the following:</p> <ul> <li>Edit any of the fields directly to change information. </li> <li>Serialize the model to JSON and save to disk.</li> <li>Deserialize JSON data back into instances of erdantic's models. </li> </ul>"},{"location":"customizing/#data-model","title":"Data model","text":"<p>The data model for erdantic has the following classes:</p> <ul> <li><code>EntityRelationshipDiagram</code> \u2014 overall container for everything in the diagram.</li> <li><code>ModelInfo</code> \u2014 stores the information of one model. Each instance gets rendered as one node in the diagram.</li> <li><code>FieldInfo</code> \u2014 stores the information of one field on a model. Each instance gets rendered as one row in the table of a node in the diagram.</li> <li><code>Edge</code> \u2014 stores the information about the relationship between a model field and another model. </li> </ul> <p>Additionally, there is a utility model <code>FullyQualifiedName</code> that stores the \"fully qualified name\", a precise reference to a model class as a Python object. This allows us to reimport that object if needed. </p> <p>An entity relationship diagram for the these models is shown below.</p> <p>erdantic fills in these fields at the time that a model is added to a diagram and the respective instance is created. After that, the values in these fields are all just static data. You can directly edit any of these fields to override the values that erdantic extracted. </p> <p>The <code>SortedDict</code> class on <code>EntityRelationshipDiagram</code> is from sortedcontainers-pydantic and allows erdantic to store models and edges in a stable ordering no matter the order that they were added to the diagram. </p>"},{"location":"customizing/#customizing-edges","title":"Customizing edges","text":"<p>erdantic uses crow's foot notation to represent the cardinality and modality of the relationships between models. Cardinality refers to the maximum number of instances of the target that can be related, with possible values of \"one\" or \"many\". Modality refers to the minimum number of instances of the target, i.e., whether it is optional, with values of \"zero\" or \"one\". </p> <p>Here are the four possible cases that erdantic will extract by default:</p> Example Type Annotation Cardinality Modality Notation <code>Target</code> one one <code>Optional[Target]</code> one zero <code>List[Target]</code> many unspecified <code>Optional[List[Target]]</code> many zero <p>You will notice that, for example, that we only have a (many, unspecified) case and no (many, one) case. While erdantic treats <code>List[Target]</code> as having ambiguous modality, if you have knowledge about your data model, you can manually override the modality value. The cardinality and modality are set on the <code>target_cardinality</code> and <code>target_modality</code> fields on an <code>Edge</code> using the <code>Cardinality</code> and <code>Modality</code> enums. These enums each have three levels:</p> <ul> <li><code>Cardinality.UNSPECIFIED</code>, <code>Cardinality.ONE</code>, <code>Cardinality.MANY</code></li> <li><code>Modality.UNSPECIFIED</code>, <code>Modality.ZERO</code>, <code>Modality.ONE</code></li> </ul> <p>When setting manually, you can use any possible combination to indicate a relationship of your choice. </p> <p><code>Edge</code> instances also have fields <code>source_cardinality</code> and <code>source_modality</code> that you can use to indicate the cardinality and modality of the source model. Edges created by erdantic will always set these to <code>Cardinality.UNSPECIFIED</code> and <code>Modality.UNSPECIFIED</code>, but you can use your own knowledge to set them to other values.  </p>"},{"location":"extending/","title":"Extending or modifying erdantic","text":"<p>Note</p> <p>The backend of erdantic was significantly updated in v1.0. This now works very differently than previous versions.</p>"},{"location":"extending/#plugins-for-model-frameworks","title":"Plugins for model frameworks","text":"<p>erdantic supports data modeling frameworks through a plugins system. Each plugin must implement specific functionality and get registered for erdantic to use it.</p> <p>The following built-in plugins are provided by erdantic:</p> <ol> <li><code>attrs</code> \u2014\u00a0for classes decorated using the attrs package</li> <li><code>dataclasses</code> \u2014\u00a0for classes decorated using the dataclasses standard library module</li> <li><code>pydantic</code> \u2014 for classes that subclass Pydantic's <code>BaseModel</code> class</li> <li><code>pydantic_v1</code> \u2014 for classes that subclass Pydantic's legacy <code>pydantic.v1.BaseModel</code> class</li> </ol> <p>It is possible to customize erdantic by registering a custom plugin, either by overriding a provided one or adding as a new one. The following sections document what you need to register your own plugin.</p>"},{"location":"extending/#components-of-a-plugin","title":"Components of a plugin","text":"<p>A plugin must implement the following two components: a predicate function and a field extractor function.</p>"},{"location":"extending/#predicate-function","title":"Predicate function","text":"<p>A predicate function takes a single object as an input and return a boolean value <code>True</code> if the object is a data model class that this plugin is for and <code>False</code> otherwise. The return type of this function is a <code>TypeGuard</code> for the model class. A protocol class <code>ModelPredicate</code> defines the specification for a valid predicate function.</p> <p>Source from <code>erdantic/plugins/__init__.py</code></p> <p>{{INJECT MODELPREDICATE SOURCE}}</p> <p>Example implementations of predicate functions include <code>is_pydantic_model</code> and <code>is_dataclass_class</code>.</p>"},{"location":"extending/#field-extractor-function","title":"Field extractor function","text":"<p>A field extractor function takes a single model class of the appropriate type and returns a sequence of <code>FieldInfo</code> instances. A protocol class <code>ModelFieldExtractor</code> defines the specification for a valid field extractor function.</p> <p>Source from <code>erdantic/plugins/__init__.py</code></p> <p>{{INJECT MODELFIELDEXTRACTOR SOURCE}}</p> <p>Example implementations of field extractor functions include <code>get_fields_from_pydantic_model</code> and <code>get_fields_from_dataclass</code>.</p> <p>The field extractor function is the place where you should try to resolve forward references. Some frameworks provide utility functions to resolve forward references, like Pydantic's <code>model_rebuild</code> and attr's <code>resolve_types</code>. If there isn't one, you should write your own using erdantic's <code>resolve_types_on_dataclass</code> as a reference implementation.</p>"},{"location":"extending/#registering-a-plugin","title":"Registering a plugin","text":"<p>A plugin must be registered by calling the <code>register_plugin</code> function with a key identifier and the two functions. If you use a key that already exists, it will overwrite the existing plugin.</p> <p>Info</p> <p>Currently, manual registration is required. This means that custom plugins can only be loaded when using erdantic as a library, and not as a CLI. In the future, we may support automatic loading of plugins that are distributed with packages through the entry points specification.</p>"},{"location":"extending/#erdantic.plugins.register_plugin","title":"register_plugin","text":"<pre><code>register_plugin(\n    key: str,\n    predicate_fn: ModelPredicate[_ModelType],\n    get_fields_fn: ModelFieldExtractor[_ModelType],\n)\n</code></pre> <p>Register a plugin for a specific model class type.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>An identifier for this plugin.</p> required <code>predicate_fn</code> <code>ModelPredicate</code> <p>A predicate function to determine if an object is a class of the model that is supported by this plugin.</p> required <code>get_fields_fn</code> <code>ModelFieldExtractor</code> <p>A function to extract fields from a model class that is supported by this plugin.</p> required"},{"location":"extending/#modifying-model-analysis-or-diagram-rendering","title":"Modifying model analysis or diagram rendering","text":"<p>If you would like to make any major changes to the functionality of erdantic, such as:</p> <ul> <li>Changing what data gets extracted when analyzing a model</li> <li>Structural changes to how models are represented in the diagram</li> </ul> <p>then you can subclass <code>EntityRelationshipDiagram</code>, <code>ModelInfo</code>, <code>FieldInfo</code>, and/or <code>Edge</code> to modify any behavior.</p> <p>Warning</p> <p>Changes like these depend on the internal APIs of erdantic and may be more likely to break between erdantic versions. If you're trying to do something like this, it would be nice to let the maintainers know in the repository discussions.</p>"},{"location":"extending/#what-to-change","title":"What to change","text":"<p>Here are some tips on what to change depending on your goals:</p> <ul> <li>To change the model-level data that is extracted and stored when analyzing a model...<ul> <li>Override <code>ModelInfo.from_raw_model</code></li> </ul> </li> <li>To change the field-level data that is extracted and stored when analyzing a model...<ul> <li>Add or override a plugin's field extractor function and/or override <code>FieldInfo.from_raw_type</code></li> </ul> </li> <li>To change the structure of the model tables in the diagram...<ul> <li>Override <code>FieldInfo.to_dot_row</code> to change the DOT code for each field's row</li> <li>Override <code>ModelInfo.to_dot_label</code> to change the table DOT code</li> </ul> </li> </ul>"},{"location":"extending/#get-erdantic-to-use-your-subclasses","title":"Get erdantic to use your subclasses","text":"<p>The best way to use custom subclasses is to subclass <code>EntityRelationshipDiagram</code>. Then, you can instantiate an instance of it and call its methods.</p> <p>Example</p> <pre><code>from erdantic.core import EntityRelationshipDiagram\nfrom erdantic.examples.pydantic import Party\n\nclass CustomEntityRelationshipDiagram(EntityRelationshipDiagram):\n    ...\n\ndiagram = CustomEntityRelationshipDiagram()\ndiagram.add_model(Party)\ndiagram.draw(\"diagram.png\")\n</code></pre> <p>Then, depending on which classes you're implementing subclasses of, you will want to do the following:</p> <ul> <li>If subclassing <code>ModelInfo</code>...<ul> <li>Also subclass <code>EntityRelationshipDiagram</code> and override the type annotation for <code>models</code> to use your custom subclass. The model info class used is determined by this type annotation.</li> </ul> </li> <li>If subclassing <code>FieldInfo</code>...<ul> <li>Also subclass <code>ModelInfo</code> and override the the type annotation for <code>fields</code> to use your custom subclass.</li> <li>Add or override a plugin's field extractor function. The field info instances are instantiated in the field extractor function.</li> </ul> </li> <li>If subclassing <code>Edge</code>...<ul> <li>Also subclass <code>EntityRelationshipDiagram</code> and override the type annotation for <code>edges</code> to use your custom subclass. The edge class used is determined by this type annotation.</li> </ul> </li> </ul>"},{"location":"extending/#example-adding-a-column-with-default-field-values","title":"Example: Adding a column with default field values","text":"<p>Below is an example that has modified handling of Pydantic models. It extracts and stores the default value for fields, and it adds them as a third column to the tables in the diagram.</p> <p>Here is how the rendered diagram looks:</p> <p></p> <p>And here is the source code:</p> <pre><code>{{INJECT PYDANTIC_WITH_DEFAULT_COLUMN SOURCE}}\n</code></pre>"},{"location":"forward-references/","title":"Handling forward references","text":"<p>Forward references are type annotations which use a string literal to declare a name that hasn't been defined yet in the code. The annotation is stored as just the name and the reference to the object is resolved later. Forward references are often useful when a class' type hints need to reference itself, or when you need to avoid a circular import through <code>if typing.TYPE_CHECKING</code>.</p> <p>In general, data modeling frameworks like Pydantic and attrs have functionality to resolve forward references automatically. For erdantic's built-in plugins, the automatic resolution should handle things in most cases without any special input from you. </p>"},{"location":"forward-references/#unresolvableforwardreferror","title":"UnresolvableForwardRefError","text":"<p>If you get a <code>UnresolvableForwardRefError</code>, that means the automatic resolution failed. Forward references must be evaluated against the right namespace, and in some cases, Python has not kept track of that namespace. The most common way for this to happen is if your model class is defined inside the local scope of a function. The way to resolve it will depend on the particular modeling framework/plugin that you're using. The exception message will tell you what to do. </p>"},{"location":"forward-references/#unevaluatedforwardreferror","title":"UnevaluatedForwardRefError","text":"<p>If you get a <code>UnevaluatedForwardRefError</code>, that means that fields were extracted from your model without evaluating forward references. </p> <p>If your model is using one of erdantic's built-in plugins, then this is unexpected behavior. The built-in plugins should attempt to automatically resolve forward references and should throw an <code>UnresolvableForwardRefError</code> as described in the previous section if unable to. Please open an issue on our GitHub repository to report this bug. </p> <p>If you are using a custom plugin, then your plugin may not be properly resolving forward references. See the \"Field extractor function\" section in the documentation about plugins for addressing this.</p>"},{"location":"api-reference/convenience/","title":"erdantic.convenience","text":""},{"location":"api-reference/convenience/#erdantic.convenience.create","title":"create","text":"<pre><code>create(\n    *models_or_modules: Union[type, ModuleType],\n    terminal_models: Collection[type] = tuple(),\n    termini: Collection[type] = tuple(),\n    limit_search_models_to: Optional[Collection[str]] = None\n) -&gt; EntityRelationshipDiagram\n</code></pre> <p>Construct <code>EntityRelationshipDiagram</code> from given data model classes or modules.</p> <p>Parameters:</p> Name Type Description Default <code>*models_or_modules</code> <code>type | ModuleType</code> <p>Data model classes to add to diagram, or modules to search for data model classes.</p> <code>()</code> <code>terminal_models</code> <code>Collection[type]</code> <p>Data model classes to set as terminal nodes. erdantic will stop searching for component classes when it reaches these models</p> <code>tuple()</code> <code>termini</code> <code>Collection[type]</code> <p>Deprecated. Use <code>terminal_models</code> instead.</p> <code>tuple()</code> <code>limit_search_models_to</code> <code>Collection[str] | None</code> <p>Plugin identifiers to limit to when searching modules for data model classes. Defaults to None which will not impose any limits.</p> <code>None</code> <p>Returns:</p> Type Description <code>EntityRelationshipDiagram</code> <p>diagram object for given data model.</p> <p>Raises:</p> Type Description <code>UnknownModelTypeError</code> <p>if a given model does not match any model types from loaded plugins.</p> <code>UnresolvableForwardRefError</code> <p>if a model contains a forward reference that cannot be automatically resolved.</p> Source code in <code>erdantic/convenience.py</code> <pre><code>def create(\n    *models_or_modules: Union[type, ModuleType],\n    terminal_models: Collection[type] = tuple(),\n    termini: Collection[type] = tuple(),\n    limit_search_models_to: Optional[Collection[str]] = None,\n) -&gt; EntityRelationshipDiagram:\n    \"\"\"Construct [`EntityRelationshipDiagram`][erdantic.core.EntityRelationshipDiagram] from given\n    data model classes or modules.\n\n    Args:\n        *models_or_modules (type | ModuleType): Data model classes to add to diagram, or modules\n            to search for data model classes.\n        terminal_models (Collection[type]): Data model classes to set as terminal nodes. erdantic\n            will stop searching for component classes when it reaches these models\n        termini (Collection[type]): Deprecated. Use `terminal_models` instead.\n        limit_search_models_to (Collection[str] | None): Plugin identifiers to limit to when\n            searching modules for data model classes. Defaults to None which will not impose any\n            limits.\n\n    Returns:\n        EntityRelationshipDiagram: diagram object for given data model.\n\n    Raises:\n        UnknownModelTypeError: if a given model does not match any model types from loaded plugins.\n        UnresolvableForwardRefError: if a model contains a forward reference that cannot be\n            automatically resolved.\n    \"\"\"\n    if termini:\n        warnings.warn(\n            \"The 'termini' argument is deprecated and will be removed in a future release. \"\n            \"Please use 'terminal_models' instead.\",\n            DeprecationWarning,\n        )\n        if terminal_models:\n            raise ValueError(\n                \"Cannot specify both 'terminal_models' and 'termini' at the same time.\"\n            )\n        terminal_models = termini\n\n    diagram = EntityRelationshipDiagram()\n\n    # Add terminal models and don't recurse\n    for model in terminal_models:\n        diagram.add_model(model, recurse=False)\n\n    for mm in models_or_modules:\n        if isinstance(mm, ModuleType):\n            logger.debug(\"Searching input module '%s' for data model classes...\", mm.__name__)\n            for member in find_models(mm, limit_search_models_to=limit_search_models_to):\n                diagram.add_model(member)\n        else:\n            diagram.add_model(mm)\n    return diagram\n</code></pre>"},{"location":"api-reference/convenience/#erdantic.convenience.draw","title":"draw","text":"<pre><code>draw(\n    *models_or_modules: Union[type, ModuleType],\n    out: Union[str, PathLike],\n    terminal_models: Collection[type] = tuple(),\n    termini: Collection[type] = tuple(),\n    limit_search_models_to: Optional[\n        Collection[str]\n    ] = None,\n    graph_attr: Optional[Mapping[str, Any]] = None,\n    node_attr: Optional[Mapping[str, Any]] = None,\n    edge_attr: Optional[Mapping[str, Any]] = None,\n    **kwargs\n)\n</code></pre> <p>Render entity relationship diagram for given data model classes to file.</p> <p>Parameters:</p> Name Type Description Default <code>*models_or_modules</code> <code>type | ModuleType</code> <p>Data model classes to add to diagram, or modules to search for data model classes.</p> <code>()</code> <code>terminal_models</code> <code>Collection[type]</code> <p>Data model classes to set as terminal nodes. erdantic will stop searching for component classes when it reaches these models</p> <code>tuple()</code> <code>termini</code> <code>Collection[type]</code> <p>Deprecated. Use <code>terminal_models</code> instead.</p> <code>tuple()</code> <code>limit_search_models_to</code> <code>Optional[Collection[str]]</code> <p>Plugin identifiers to limit to when searching modules for data model classes. Defaults to None which will not impose any limits.</p> <code>None</code> <code>graph_attr</code> <code>Mapping[str, Any] | None</code> <p>Override any graph attributes on the <code>pygraphviz.AGraph</code> instance. Defaults to None.</p> <code>None</code> <code>node_attr</code> <code>Mapping[str, Any] | None</code> <p>Override any node attributes for all nodes on the <code>pygraphviz.AGraph</code> instance. Defaults to None.</p> <code>None</code> <code>edge_attr</code> <code>Mapping[str, Any] | None</code> <p>Override any edge attributes for all edges on the <code>pygraphviz.AGraph</code> instance. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to <code>pygraphviz.AGraph.draw</code>.</p> <code>{}</code> <p>Raises:</p> Type Description <code>UnknownModelTypeError</code> <p>if a given model does not match any model types from loaded plugins.</p> <code>UnresolvableForwardRefError</code> <p>if a model contains a forward reference that cannot be automatically resolved.</p> Source code in <code>erdantic/convenience.py</code> <pre><code>def draw(\n    *models_or_modules: Union[type, ModuleType],\n    out: Union[str, os.PathLike],\n    terminal_models: Collection[type] = tuple(),\n    termini: Collection[type] = tuple(),\n    limit_search_models_to: Optional[Collection[str]] = None,\n    graph_attr: Optional[Mapping[str, Any]] = None,\n    node_attr: Optional[Mapping[str, Any]] = None,\n    edge_attr: Optional[Mapping[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Render entity relationship diagram for given data model classes to file.\n\n    Args:\n        *models_or_modules (type | ModuleType): Data model classes to add to diagram, or modules\n            to search for data model classes.\n        terminal_models (Collection[type]): Data model classes to set as terminal nodes. erdantic\n            will stop searching for component classes when it reaches these models\n        termini (Collection[type]): Deprecated. Use `terminal_models` instead.\n        limit_search_models_to (Optional[Collection[str]]): Plugin identifiers to limit to when\n            searching modules for data model classes. Defaults to None which will not impose any\n            limits.\n        graph_attr (Mapping[str, Any] | None, optional): Override any graph attributes on\n            the `pygraphviz.AGraph` instance. Defaults to None.\n        node_attr (Mapping[str, Any] | None, optional): Override any node attributes for all\n            nodes on the `pygraphviz.AGraph` instance. Defaults to None.\n        edge_attr (Mapping[str, Any] | None, optional): Override any edge attributes for all\n            edges on the `pygraphviz.AGraph` instance. Defaults to None.\n        **kwargs: Additional keyword arguments to\n            [`pygraphviz.AGraph.draw`][pygraphviz.AGraph.draw].\n\n    Raises:\n        UnknownModelTypeError: if a given model does not match any model types from loaded plugins.\n        UnresolvableForwardRefError: if a model contains a forward reference that cannot be\n            automatically resolved.\n    \"\"\"\n    diagram = create(\n        *models_or_modules,\n        terminal_models=terminal_models,\n        limit_search_models_to=limit_search_models_to,\n    )\n    diagram.draw(\n        out=out, graph_attr=graph_attr, node_attr=node_attr, edge_attr=edge_attr, **kwargs\n    )\n</code></pre>"},{"location":"api-reference/convenience/#erdantic.convenience.find_models","title":"find_models","text":"<pre><code>find_models(\n    module: ModuleType,\n    limit_search_models_to: Optional[\n        Collection[str]\n    ] = None,\n) -&gt; Iterator[type]\n</code></pre> <p>Searches a module and yields all data model classes found.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>ModuleType</code> <p>Module to search for data model classes.</p> required <code>limit_search_models_to</code> <code>Collection[str] | None</code> <p>Plugin identifiers to limit to when searching modules for data model classes. Defaults to None which will not impose any limits.</p> <code>None</code> <p>Yields:</p> Type Description <code>type</code> <p>Iterator[type]: Members of module that are data model classes.</p> <p>Raises:</p> Type Description <code>UnknownModelTypeError</code> <p>if a given model does not match any model types from loaded plugins.</p> <code>UnresolvableForwardRefError</code> <p>if a model contains a forward reference that cannot be automatically resolved.</p> Source code in <code>erdantic/convenience.py</code> <pre><code>def find_models(\n    module: ModuleType, limit_search_models_to: Optional[Collection[str]] = None\n) -&gt; Iterator[type]:\n    \"\"\"Searches a module and yields all data model classes found.\n\n    Args:\n        module (ModuleType): Module to search for data model classes.\n        limit_search_models_to (Collection[str] | None): Plugin identifiers to limit to when\n            searching modules for data model classes. Defaults to None which will not impose any\n            limits.\n\n    Yields:\n        Iterator[type]: Members of module that are data model classes.\n\n    Raises:\n        UnknownModelTypeError: if a given model does not match any model types from loaded plugins.\n        UnresolvableForwardRefError: if a model contains a forward reference that cannot be\n            automatically resolved.\n    \"\"\"\n    all_plugins = list_plugins()\n    if limit_search_models_to is not None:\n        predicate_fns = [get_predicate_fn(key) for key in limit_search_models_to]\n    else:\n        predicate_fns = [get_predicate_fn(key) for key in all_plugins]\n    for _, member in inspect.getmembers(module, inspect.isclass):\n        if member.__module__ == module.__name__:\n            for predicate_fn in predicate_fns:\n                if predicate_fn(member):\n                    logger.debug(\n                        \"Found data model class '%s' in module '%s'\",\n                        typenames(member, remove_modules=REMOVE_ALL_MODULES),\n                        module.__name__,\n                    )\n                    yield member\n</code></pre>"},{"location":"api-reference/convenience/#erdantic.convenience.to_dot","title":"to_dot","text":"<pre><code>to_dot(\n    *models_or_modules: Union[type, ModuleType],\n    terminal_models: Collection[type] = [],\n    termini: Collection[type] = tuple(),\n    limit_search_models_to: Optional[\n        Collection[str]\n    ] = None,\n    graph_attr: Optional[Mapping[str, Any]] = None,\n    node_attr: Optional[Mapping[str, Any]] = None,\n    edge_attr: Optional[Mapping[str, Any]] = None\n) -&gt; str\n</code></pre> <p>Generate Graphviz DOT language representation of entity relationship diagram for given data model classes.</p> <p>Parameters:</p> Name Type Description Default <code>*models_or_modules</code> <code>type | ModuleType</code> <p>Data model classes to add to diagram, or modules to search for data model classes.</p> <code>()</code> <code>terminal_models</code> <code>Collection[type]</code> <p>Data model classes to set as terminal nodes. erdantic will stop searching for component classes when it reaches these models</p> <code>[]</code> <code>termini</code> <code>Collection[type]</code> <p>Deprecated. Use <code>terminal_models</code> instead.</p> <code>tuple()</code> <code>limit_search_models_to</code> <code>Optional[Collection[str]]</code> <p>Plugin identifiers to limit to when searching modules for data model classes. Defaults to None which will not impose any limits.</p> <code>None</code> <code>graph_attr</code> <code>Mapping[str, Any] | None</code> <p>Override any graph attributes on the <code>pygraphviz.AGraph</code> instance. Defaults to None.</p> <code>None</code> <code>node_attr</code> <code>Mapping[str, Any] | None</code> <p>Override any node attributes for all nodes on the <code>pygraphviz.AGraph</code> instance. Defaults to None.</p> <code>None</code> <code>edge_attr</code> <code>Mapping[str, Any] | None</code> <p>Override any edge attributes for all edges on the <code>pygraphviz.AGraph</code> instance. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>DOT language representation of diagram</p> Source code in <code>erdantic/convenience.py</code> <pre><code>def to_dot(\n    *models_or_modules: Union[type, ModuleType],\n    terminal_models: Collection[type] = [],\n    termini: Collection[type] = tuple(),\n    limit_search_models_to: Optional[Collection[str]] = None,\n    graph_attr: Optional[Mapping[str, Any]] = None,\n    node_attr: Optional[Mapping[str, Any]] = None,\n    edge_attr: Optional[Mapping[str, Any]] = None,\n) -&gt; str:\n    \"\"\"Generate Graphviz [DOT language](https://graphviz.org/doc/info/lang.html) representation of\n    entity relationship diagram for given data model classes.\n\n    Args:\n        *models_or_modules (type | ModuleType): Data model classes to add to diagram, or modules\n            to search for data model classes.\n        terminal_models (Collection[type]): Data model classes to set as terminal nodes. erdantic\n            will stop searching for component classes when it reaches these models\n        termini (Collection[type]): Deprecated. Use `terminal_models` instead.\n        limit_search_models_to (Optional[Collection[str]]): Plugin identifiers to limit to when\n            searching modules for data model classes. Defaults to None which will not impose any\n            limits.\n        graph_attr (Mapping[str, Any] | None, optional): Override any graph attributes on\n            the `pygraphviz.AGraph` instance. Defaults to None.\n        node_attr (Mapping[str, Any] | None, optional): Override any node attributes for all\n            nodes on the `pygraphviz.AGraph` instance. Defaults to None.\n        edge_attr (Mapping[str, Any] | None, optional): Override any edge attributes for all\n            edges on the `pygraphviz.AGraph` instance. Defaults to None.\n\n    Returns:\n        str: DOT language representation of diagram\n    \"\"\"\n    diagram = create(\n        *models_or_modules,\n        terminal_models=terminal_models,\n        termini=termini,\n        limit_search_models_to=limit_search_models_to,\n    )\n    return diagram.to_dot(graph_attr=graph_attr, node_attr=node_attr, edge_attr=edge_attr)\n</code></pre>"},{"location":"api-reference/core/","title":"erdantic.core","text":""},{"location":"api-reference/core/#erdantic.core.DEFAULT_EDGE_ATTR","title":"DEFAULT_EDGE_ATTR  <code>module-attribute</code>","text":"<pre><code>DEFAULT_EDGE_ATTR = (('dir', 'both'))\n</code></pre> <p>Default edge attributes passed to Graphviz.</p>"},{"location":"api-reference/core/#erdantic.core.DEFAULT_GRAPH_ATTR","title":"DEFAULT_GRAPH_ATTR  <code>module-attribute</code>","text":"<pre><code>DEFAULT_GRAPH_ATTR = (\n    (\"nodesep\", \"0.5\"),\n    (\"ranksep\", \"1.5\"),\n    (\"rankdir\", \"LR\"),\n    (\n        \"label\",\n        f\"Created by erdantic v{__version__} &lt;https://github.com/drivendataorg/erdantic&gt;\",\n    ),\n    (\n        \"fontname\",\n        \"Times New Roman,Times,Liberation Serif,serif\",\n    ),\n    (\"fontsize\", \"9\"),\n    (\"fontcolor\", \"gray66\"),\n)\n</code></pre> <p>Default graph attributes passed to Graphviz.</p>"},{"location":"api-reference/core/#erdantic.core.DEFAULT_NODE_ATTR","title":"DEFAULT_NODE_ATTR  <code>module-attribute</code>","text":"<pre><code>DEFAULT_NODE_ATTR = (\n    (\n        \"fontname\",\n        \"Times New Roman,Times,Liberation Serif,serif\",\n    ),\n    (\"fontsize\", 14),\n    (\"shape\", \"plain\"),\n)\n</code></pre> <p>Default node attributes passed to Graphviz.</p>"},{"location":"api-reference/core/#erdantic.core.Cardinality","title":"Cardinality","text":"<p>             Bases: <code>Enum</code></p> <p>Enumeration of possible cardinality values for a relationship between two data model classes. Cardinality measures the maximum number of associations.</p> Source code in <code>erdantic/core.py</code> <pre><code>class Cardinality(Enum):\n    \"\"\"Enumeration of possible cardinality values for a relationship between two data model\n    classes. Cardinality measures the maximum number of associations.\n    \"\"\"\n\n    UNSPECIFIED = \"unspecified\"\n    ONE = \"one\"\n    MANY = \"many\"\n\n    def to_dot(self) -&gt; str:\n        \"\"\"Returns the DOT language specification for the arrowhead styling associated with the\n        cardinality value.\n        \"\"\"\n        return _CARDINALITY_DOT_MAPPING[self]\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.Cardinality.to_dot","title":"to_dot","text":"<pre><code>to_dot() -&gt; str\n</code></pre> <p>Returns the DOT language specification for the arrowhead styling associated with the cardinality value.</p> Source code in <code>erdantic/core.py</code> <pre><code>def to_dot(self) -&gt; str:\n    \"\"\"Returns the DOT language specification for the arrowhead styling associated with the\n    cardinality value.\n    \"\"\"\n    return _CARDINALITY_DOT_MAPPING[self]\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.Edge","title":"Edge","text":"<p>             Bases: <code>BaseModel</code></p> <p>Hold information about a relationship between two data model classes. These represent directed edges in the entity relationship diagram.</p> <p>Attributes:</p> Name Type Description <code>source_model_full_name</code> <code>FullyQualifiedName</code> <p>Fully qualified name of the source model, i.e., the model that contains a field that references the target model.</p> <code>source_field_name</code> <code>str</code> <p>Name of the field on the source model that references the target model.</p> <code>target_model_full_name</code> <code>FullyQualifiedName</code> <p>Fully qualified name of the target model, i.e., the model that is referenced by the source model's field.</p> <code>target_cardinality</code> <code>Cardinality</code> <p>Cardinality of the target model in the relationship, e.g., if the relationship is one (source) to many (target), this value will be <code>Cardinality.MANY</code>.</p> <code>target_modality</code> <code>Modality</code> <p>Modality of the target model in the relationship, e.g., if the relationship is one (source) to zero (target), meaning that the target is optional, this value will be <code>Modality.ZERO</code>.</p> <code>source_cardinality</code> <code>Optional[Cardinality]</code> <p>Cardinality of the source model in the relationship. This will never be set for Edges created by erdantic, but you can set it manually to notate an externally known cardinality.</p> <code>source_modality</code> <code>Optional[Modality]</code> <p>Modality of the source model in the relationship. This will never be set for Edges created by erdantic, but you can set it manually to notate an externally known modality.</p> Source code in <code>erdantic/core.py</code> <pre><code>@add_repr_pretty_to_pydantic\nclass Edge(pydantic.BaseModel):\n    \"\"\"Hold information about a relationship between two data model classes. These represent\n    directed edges in the entity relationship diagram.\n\n    Attributes:\n        source_model_full_name (FullyQualifiedName): Fully qualified name of the source model,\n            i.e., the model that contains a field that references the target model.\n        source_field_name (str): Name of the field on the source model that references the target\n            model.\n        target_model_full_name (FullyQualifiedName): Fully qualified name of the target model,\n            i.e., the model that is referenced by the source model's field.\n        target_cardinality (Cardinality): Cardinality of the target model in the relationship,\n            e.g., if the relationship is one (source) to many (target), this value will be\n            `Cardinality.MANY`.\n        target_modality (Modality): Modality of the target model in the relationship, e.g., if the\n            relationship is one (source) to zero (target), meaning that the target is optional,\n            this value will be `Modality.ZERO`.\n        source_cardinality (Optional[Cardinality]): Cardinality of the source model in the\n            relationship. This will never be set for Edges created by erdantic, but you can set it\n            manually to notate an externally known cardinality.\n        source_modality (Optional[Modality]): Modality of the source model in the relationship.\n            This will never be set for Edges created by erdantic, but you can set it manually to\n            notate an externally known modality.\n    \"\"\"\n\n    source_model_full_name: FullyQualifiedName\n    source_field_name: str\n    target_model_full_name: FullyQualifiedName\n    target_cardinality: Cardinality\n    target_modality: Modality\n    source_cardinality: Cardinality = Cardinality.UNSPECIFIED\n    source_modality: Modality = Modality.UNSPECIFIED\n\n    @property\n    def key(self) -&gt; str:\n        \"\"\"Returns the key used to identify this instance of Edge in the\n        EntityRelationshipDiagram.edges mapping. This value is a hyphenated string of the fields\n        `source_model_full_name`, `source_field_name`, and `target_model_full_name`.\n        \"\"\"\n        return \"-\".join(\n            str(part)\n            for part in (\n                self.source_model_full_name,\n                self.source_field_name,\n                self.target_model_full_name,\n            )\n        )\n\n    @classmethod\n    def from_field_info(cls, target_model: type, source_field_info: FieldInfo) -&gt; Self:\n        \"\"\"Constructor method to create a new instance from a target model instance and a source\n        model's FieldInfo.\n\n        Args:\n            target_model (type): Target model class.\n            source_field_info (FieldInfo): FieldInfo instance for the field on the source model\n                that references the target model.\n\n        Returns:\n            Self: New instance of Edge.\n        \"\"\"\n        is_collection = is_collection_type_of(source_field_info.raw_type, target_model)\n        is_nullable = is_nullable_type(source_field_info.raw_type)\n        cardinality = Cardinality.MANY if is_collection else Cardinality.ONE\n        if is_nullable:\n            modality = Modality.ZERO\n        else:\n            modality = Modality.UNSPECIFIED if is_collection else Modality.ONE\n        return cls(\n            source_model_full_name=source_field_info.model_full_name,\n            source_field_name=source_field_info.name,\n            target_model_full_name=FullyQualifiedName.from_object(target_model),\n            target_cardinality=cardinality,\n            target_modality=modality,\n        )\n\n    def target_dot_arrow_shape(self) -&gt; str:\n        \"\"\"Arrow shape specification in Graphviz DOT language for this edge's head (the end at the\n        target model). See [Graphviz docs](https://graphviz.org/doc/info/arrows.html) as a\n        reference. Shape returned is based on\n        [crow's foot notation](https://www.gleek.io/blog/crows-foot-notation) for the\n        relationship's cardinality and modality.\n\n        Returns:\n            str: DOT language specification for arrow shape of this edge's head\n        \"\"\"\n        return self.target_cardinality.to_dot() + self.target_modality.to_dot()\n\n    def source_dot_arrow_shape(self) -&gt; str:\n        \"\"\"Arrow shape specification in Graphviz DOT language for this edge's tail (the end at the\n        source model). See [Graphviz docs](https://graphviz.org/doc/info/arrows.html) as a\n        reference. Shape returned is based on\n        [crow's foot notation](https://www.gleek.io/blog/crows-foot-notation) for the\n        relationship's cardinality and modality.\n\n        Returns:\n            str: DOT language specification for arrow shape of this edge's tail\n        \"\"\"\n        return self.source_cardinality.to_dot() + self.source_modality.to_dot()\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.Edge.key","title":"key  <code>property</code>","text":"<pre><code>key: str\n</code></pre> <p>Returns the key used to identify this instance of Edge in the EntityRelationshipDiagram.edges mapping. This value is a hyphenated string of the fields <code>source_model_full_name</code>, <code>source_field_name</code>, and <code>target_model_full_name</code>.</p>"},{"location":"api-reference/core/#erdantic.core.Edge.from_field_info","title":"from_field_info  <code>classmethod</code>","text":"<pre><code>from_field_info(\n    target_model: type, source_field_info: FieldInfo\n) -&gt; Self\n</code></pre> <p>Constructor method to create a new instance from a target model instance and a source model's FieldInfo.</p> <p>Parameters:</p> Name Type Description Default <code>target_model</code> <code>type</code> <p>Target model class.</p> required <code>source_field_info</code> <code>FieldInfo</code> <p>FieldInfo instance for the field on the source model that references the target model.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>New instance of Edge.</p> Source code in <code>erdantic/core.py</code> <pre><code>@classmethod\ndef from_field_info(cls, target_model: type, source_field_info: FieldInfo) -&gt; Self:\n    \"\"\"Constructor method to create a new instance from a target model instance and a source\n    model's FieldInfo.\n\n    Args:\n        target_model (type): Target model class.\n        source_field_info (FieldInfo): FieldInfo instance for the field on the source model\n            that references the target model.\n\n    Returns:\n        Self: New instance of Edge.\n    \"\"\"\n    is_collection = is_collection_type_of(source_field_info.raw_type, target_model)\n    is_nullable = is_nullable_type(source_field_info.raw_type)\n    cardinality = Cardinality.MANY if is_collection else Cardinality.ONE\n    if is_nullable:\n        modality = Modality.ZERO\n    else:\n        modality = Modality.UNSPECIFIED if is_collection else Modality.ONE\n    return cls(\n        source_model_full_name=source_field_info.model_full_name,\n        source_field_name=source_field_info.name,\n        target_model_full_name=FullyQualifiedName.from_object(target_model),\n        target_cardinality=cardinality,\n        target_modality=modality,\n    )\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.Edge.source_dot_arrow_shape","title":"source_dot_arrow_shape","text":"<pre><code>source_dot_arrow_shape() -&gt; str\n</code></pre> <p>Arrow shape specification in Graphviz DOT language for this edge's tail (the end at the source model). See Graphviz docs as a reference. Shape returned is based on crow's foot notation for the relationship's cardinality and modality.</p> <p>Returns:</p> Type Description <code>str</code> <p>DOT language specification for arrow shape of this edge's tail</p> Source code in <code>erdantic/core.py</code> <pre><code>def source_dot_arrow_shape(self) -&gt; str:\n    \"\"\"Arrow shape specification in Graphviz DOT language for this edge's tail (the end at the\n    source model). See [Graphviz docs](https://graphviz.org/doc/info/arrows.html) as a\n    reference. Shape returned is based on\n    [crow's foot notation](https://www.gleek.io/blog/crows-foot-notation) for the\n    relationship's cardinality and modality.\n\n    Returns:\n        str: DOT language specification for arrow shape of this edge's tail\n    \"\"\"\n    return self.source_cardinality.to_dot() + self.source_modality.to_dot()\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.Edge.target_dot_arrow_shape","title":"target_dot_arrow_shape","text":"<pre><code>target_dot_arrow_shape() -&gt; str\n</code></pre> <p>Arrow shape specification in Graphviz DOT language for this edge's head (the end at the target model). See Graphviz docs as a reference. Shape returned is based on crow's foot notation for the relationship's cardinality and modality.</p> <p>Returns:</p> Type Description <code>str</code> <p>DOT language specification for arrow shape of this edge's head</p> Source code in <code>erdantic/core.py</code> <pre><code>def target_dot_arrow_shape(self) -&gt; str:\n    \"\"\"Arrow shape specification in Graphviz DOT language for this edge's head (the end at the\n    target model). See [Graphviz docs](https://graphviz.org/doc/info/arrows.html) as a\n    reference. Shape returned is based on\n    [crow's foot notation](https://www.gleek.io/blog/crows-foot-notation) for the\n    relationship's cardinality and modality.\n\n    Returns:\n        str: DOT language specification for arrow shape of this edge's head\n    \"\"\"\n    return self.target_cardinality.to_dot() + self.target_modality.to_dot()\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.EntityRelationshipDiagram","title":"EntityRelationshipDiagram","text":"<p>             Bases: <code>BaseModel</code></p> <p>Holds information about an entity relationship diagram for a set of data model classes and their relationships, and provides methods to render the diagram.</p> <p>Attributes:</p> Name Type Description <code>models</code> <code>SortedDict[str, ModelInfo]</code> <p>Mapping of ModelInfo instances for models included in the diagram. Each key is the string representation of the fully qualified name of the model.</p> <code>edges</code> <code>SortedSet[Edge]</code> <p>Set of edges representing relationships between the models.</p> Source code in <code>erdantic/core.py</code> <pre><code>class EntityRelationshipDiagram(pydantic.BaseModel):\n    \"\"\"Holds information about an entity relationship diagram for a set of data model classes and\n    their relationships, and provides methods to render the diagram.\n\n    Attributes:\n        models (SortedDict[str, ModelInfo]): Mapping of ModelInfo instances for models included\n            in the diagram. Each key is the string representation of the fully qualified name of\n            the model.\n        edges (SortedSet[Edge]): Set of edges representing relationships between the models.\n    \"\"\"\n\n    models: SortedDict[str, ModelInfo] = SortedDict()\n    edges: SortedDict[str, Edge] = SortedDict()\n\n    model_config = pydantic.ConfigDict(\n        validate_default=True,\n    )\n\n    @property\n    def _model_info_cls(self) -&gt; Type[ModelInfo]:\n        \"\"\"Returns the model info class used by this diagram class. For the normal\n        EntityRelationshipDiagram class, this is erdantic.core.ModelInfo.\"\"\"\n        annotation = self.model_fields[\"models\"].annotation\n        args = get_args(annotation)\n        return args[1]\n\n    @property\n    def _edge_cls(self) -&gt; Type[Edge]:\n        \"\"\"Returns the edge class used by this diagram class. For the normal\n        EntityRelationshipDiagram class, this is erdantic.core.Edge.\"\"\"\n        annotation = self.model_fields[\"edges\"].annotation\n        args = get_args(annotation)\n        return args[1]\n\n    def _add_if_model(self, model: type, recurse: bool) -&gt; bool:\n        \"\"\"Private recursive method to add a model to the diagram.\"\"\"\n        key = str(FullyQualifiedName.from_object(model))\n        if key not in self.models:\n            try:\n                model_info = self._model_info_cls.from_raw_model(model)\n                self.models[key] = model_info\n                logger.debug(\"Sucessfully added model '%s'.\", key)\n                if recurse:\n                    logger.debug(\"Searching fields of '%s' for other models...\", key)\n                    for field_info in model_info.fields.values():\n                        logger.debug(\n                            \"Analyzing model '%s' field '%s' of type '%s'...\",\n                            key,\n                            field_info.name,\n                            field_info.type_name,\n                        )\n                        try:\n                            for arg in get_recursive_args(field_info.raw_type):\n                                is_model = self._add_if_model(arg, recurse=recurse)\n                                if is_model:\n                                    edge = self._edge_cls.from_field_info(arg, field_info)\n                                    self.edges[edge.key] = edge\n                                    logger.debug(\n                                        \"Added edge from model '%s' field '%s' to model '%s'.\",\n                                        edge.source_model_full_name,\n                                        edge.source_field_name,\n                                        edge.target_model_full_name,\n                                    )\n                        except _UnevaluatedForwardRefError as e:\n                            raise UnevaluatedForwardRefError(\n                                model_full_name=model_info.full_name,\n                                field_name=field_info.name,\n                                forward_ref=e.forward_ref,\n                            )\n            except UnknownModelTypeError:\n                return False\n        else:\n            logger.debug(\"Model '%s' already exists in diagram.\", key)\n        return True\n\n    def add_model(self, model: type, recurse=True):\n        \"\"\"Add a data model class to the diagram.\n\n        Args:\n            model (type): Data model class to add to the diagram.\n            recurse (bool, optional): Whether to recursively add models referenced by fields of\n                the given model. Defaults to True.\n\n        Raises:\n            UnknownModelTypeError: If the model is not recognized as a data model class type that\n                is supported by registered plugins.\n            UnresolvableForwardRefError: If the model contains a forward reference that cannot be\n                automatically resolved.\n        \"\"\"\n        logger.info(\"Adding model '%s' to diagram...\", typenames(model))\n        is_model = self._add_if_model(model, recurse=recurse)\n        if not is_model:\n            raise UnknownModelTypeError(model=model, available_plugins=list_plugins())\n\n    def draw(\n        self,\n        out: Union[str, os.PathLike],\n        graph_attr: Optional[Mapping[str, Any]] = None,\n        node_attr: Optional[Mapping[str, Any]] = None,\n        edge_attr: Optional[Mapping[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Render entity relationship diagram for given data model classes to file. The file format\n        can be inferred from the file extension. Typical formats include '.png', '.svg', and\n        '.pdf'.\n\n        Args:\n            out (str | os.PathLike): Output file path for rendered diagram.\n            graph_attr (Mapping[str, Any] | None, optional): Override any graph attributes on\n                the `pygraphviz.AGraph` instance. Defaults to None.\n            node_attr (Mapping[str, Any] | None, optional): Override any node attributes for all\n                nodes on the `pygraphviz.AGraph` instance. Defaults to None.\n            edge_attr (Mapping[str, Any] | None, optional): Override any edge attributes for all\n                edges on the `pygraphviz.AGraph` instance. Defaults to None.\n            **kwargs: Additional keyword arguments to\n                [`pygraphviz.AGraph.draw`][pygraphviz.AGraph.draw].\n        \"\"\"\n        logger.info(\"Rendering diagram to %s\", out)\n        self.to_graphviz(\n            graph_attr=graph_attr,\n            node_attr=node_attr,\n            edge_attr=edge_attr,\n        ).draw(out, prog=\"dot\", **kwargs)\n\n    def to_graphviz(\n        self,\n        graph_attr: Optional[Mapping[str, Any]] = None,\n        node_attr: Optional[Mapping[str, Any]] = None,\n        edge_attr: Optional[Mapping[str, Any]] = None,\n    ) -&gt; pgv.AGraph:\n        \"\"\"Return [`pygraphviz.AGraph`][pygraphviz.agraph.AGraph] instance for diagram.\n\n        Args:\n            graph_attr (Mapping[str, Any] | None, optional): Override any graph attributes on\n                the `pygraphviz.AGraph` instance. Defaults to None.\n            node_attr (Mapping[str, Any] | None, optional): Override any node attributes for all\n                nodes on the `pygraphviz.AGraph` instance. Defaults to None.\n            edge_attr (Mapping[str, Any] | None, optional): Override any edge attributes for all\n                edges on the `pygraphviz.AGraph` instance. Defaults to None.\n\n        Returns:\n            pygraphviz.AGraph: graph object for diagram\n        \"\"\"\n        g = pgv.AGraph(\n            name=\"Entity Relationship Diagram created by erdantic\",\n            directed=True,\n            strict=False,\n        )\n        g.graph_attr.update(DEFAULT_GRAPH_ATTR)\n        g.graph_attr.update(graph_attr or {})\n        g.node_attr.update(DEFAULT_NODE_ATTR)\n        g.node_attr.update(node_attr or {})\n        g.edge_attr.update(DEFAULT_EDGE_ATTR)\n        g.edge_attr.update(edge_attr or {})\n        for full_name, model_info in self.models.items():\n            g.add_node(\n                full_name,\n                label=model_info.to_dot_label(),\n                tooltip=model_info.description.replace(\"\\n\", \"&amp;#xA;\"),\n            )\n        for edge in self.edges.values():\n            g.add_edge(\n                edge.source_model_full_name,\n                edge.target_model_full_name,\n                tailport=f\"{edge.source_field_name}:e\",\n                headport=\"_root:w\",\n                arrowhead=edge.target_dot_arrow_shape(),\n                arrowtail=edge.source_dot_arrow_shape(),\n            )\n        return g\n\n    def to_dot(\n        self,\n        graph_attr: Optional[Mapping[str, Any]] = None,\n        node_attr: Optional[Mapping[str, Any]] = None,\n        edge_attr: Optional[Mapping[str, Any]] = None,\n    ) -&gt; str:\n        \"\"\"Generate Graphviz [DOT language](https://graphviz.org/doc/info/lang.html) representation\n        of entity relationship diagram for given data model classes.\n\n        Args:\n            graph_attr (Mapping[str, Any] | None, optional): Override any graph attributes on\n                the `pygraphviz.AGraph` instance. Defaults to None.\n            node_attr (Mapping[str, Any] | None, optional): Override any node attributes for all\n                nodes on the `pygraphviz.AGraph` instance. Defaults to None.\n            edge_attr (Mapping[str, Any] | None, optional): Override any edge attributes for all\n                edges on the `pygraphviz.AGraph` instance. Defaults to None.\n\n        Returns:\n            str: DOT language representation of diagram\n        \"\"\"\n        return self.to_graphviz(\n            graph_attr=graph_attr,\n            node_attr=node_attr,\n            edge_attr=edge_attr,\n        ).string()\n\n    def _repr_pretty_(self, p, cycle):\n        \"\"\"IPython special method to pretty-print an object.\"\"\"\n        try:\n            # Try using rich if it's available, since rich is nicer\n            import rich  # type: ignore [import-not-found]\n\n            rich.print(self)\n        except ModuleNotFoundError:\n            if cycle:\n                p.text(repr(self))\n            else:\n                with p.group(1, f\"{self.__class__.__name__}(\", \")\"):\n                    # Render models as a dictionary with ModelInfo objects abbreviated\n                    p.text(\"models=\")\n                    p.pretty(\n                        {k: ellipsis_arg_repr_factory(type(v)) for k, v in self.models.items()}\n                    )\n                    p.text(\",\")\n                    p.breakable()\n                    # Render edges as a dictionary with Edge objects abbreviated\n                    p.text(\"edges=\")\n                    p.pretty(\n                        {k: ellipsis_arg_repr_factory(type(v)) for k, v in self.edges.items()}\n                    )\n                    p.breakable()\n\n    def _repr_png_(self) -&gt; bytes:\n        \"\"\"IPython special method to display object as a PNG image.\"\"\"\n        graph = self.to_graphviz()\n        return graph.draw(prog=\"dot\", format=\"png\")\n\n    def _repr_svg_(self) -&gt; str:\n        \"\"\"IPython special method to display object as an SVG image.\"\"\"\n        graph = self.to_graphviz()\n        return graph.draw(prog=\"dot\", format=\"svg\").decode(graph.encoding)\n\n    def __rich_repr__(self):\n        \"\"\"Rich special method to format the representation of an object.\"\"\"\n        yield \"models\", {k: ellipsis_arg_repr_factory(type(v)) for k, v in self.models.items()}\n        yield \"edges\", {k: ellipsis_arg_repr_factory(type(v)) for k, v in self.edges.items()}\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.EntityRelationshipDiagram.add_model","title":"add_model","text":"<pre><code>add_model(model: type, recurse=True)\n</code></pre> <p>Add a data model class to the diagram.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type</code> <p>Data model class to add to the diagram.</p> required <code>recurse</code> <code>bool</code> <p>Whether to recursively add models referenced by fields of the given model. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>UnknownModelTypeError</code> <p>If the model is not recognized as a data model class type that is supported by registered plugins.</p> <code>UnresolvableForwardRefError</code> <p>If the model contains a forward reference that cannot be automatically resolved.</p> Source code in <code>erdantic/core.py</code> <pre><code>def add_model(self, model: type, recurse=True):\n    \"\"\"Add a data model class to the diagram.\n\n    Args:\n        model (type): Data model class to add to the diagram.\n        recurse (bool, optional): Whether to recursively add models referenced by fields of\n            the given model. Defaults to True.\n\n    Raises:\n        UnknownModelTypeError: If the model is not recognized as a data model class type that\n            is supported by registered plugins.\n        UnresolvableForwardRefError: If the model contains a forward reference that cannot be\n            automatically resolved.\n    \"\"\"\n    logger.info(\"Adding model '%s' to diagram...\", typenames(model))\n    is_model = self._add_if_model(model, recurse=recurse)\n    if not is_model:\n        raise UnknownModelTypeError(model=model, available_plugins=list_plugins())\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.EntityRelationshipDiagram.draw","title":"draw","text":"<pre><code>draw(\n    out: Union[str, PathLike],\n    graph_attr: Optional[Mapping[str, Any]] = None,\n    node_attr: Optional[Mapping[str, Any]] = None,\n    edge_attr: Optional[Mapping[str, Any]] = None,\n    **kwargs\n)\n</code></pre> <p>Render entity relationship diagram for given data model classes to file. The file format can be inferred from the file extension. Typical formats include '.png', '.svg', and '.pdf'.</p> <p>Parameters:</p> Name Type Description Default <code>out</code> <code>str | PathLike</code> <p>Output file path for rendered diagram.</p> required <code>graph_attr</code> <code>Mapping[str, Any] | None</code> <p>Override any graph attributes on the <code>pygraphviz.AGraph</code> instance. Defaults to None.</p> <code>None</code> <code>node_attr</code> <code>Mapping[str, Any] | None</code> <p>Override any node attributes for all nodes on the <code>pygraphviz.AGraph</code> instance. Defaults to None.</p> <code>None</code> <code>edge_attr</code> <code>Mapping[str, Any] | None</code> <p>Override any edge attributes for all edges on the <code>pygraphviz.AGraph</code> instance. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments to <code>pygraphviz.AGraph.draw</code>.</p> <code>{}</code> Source code in <code>erdantic/core.py</code> <pre><code>def draw(\n    self,\n    out: Union[str, os.PathLike],\n    graph_attr: Optional[Mapping[str, Any]] = None,\n    node_attr: Optional[Mapping[str, Any]] = None,\n    edge_attr: Optional[Mapping[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Render entity relationship diagram for given data model classes to file. The file format\n    can be inferred from the file extension. Typical formats include '.png', '.svg', and\n    '.pdf'.\n\n    Args:\n        out (str | os.PathLike): Output file path for rendered diagram.\n        graph_attr (Mapping[str, Any] | None, optional): Override any graph attributes on\n            the `pygraphviz.AGraph` instance. Defaults to None.\n        node_attr (Mapping[str, Any] | None, optional): Override any node attributes for all\n            nodes on the `pygraphviz.AGraph` instance. Defaults to None.\n        edge_attr (Mapping[str, Any] | None, optional): Override any edge attributes for all\n            edges on the `pygraphviz.AGraph` instance. Defaults to None.\n        **kwargs: Additional keyword arguments to\n            [`pygraphviz.AGraph.draw`][pygraphviz.AGraph.draw].\n    \"\"\"\n    logger.info(\"Rendering diagram to %s\", out)\n    self.to_graphviz(\n        graph_attr=graph_attr,\n        node_attr=node_attr,\n        edge_attr=edge_attr,\n    ).draw(out, prog=\"dot\", **kwargs)\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.EntityRelationshipDiagram.to_dot","title":"to_dot","text":"<pre><code>to_dot(\n    graph_attr: Optional[Mapping[str, Any]] = None,\n    node_attr: Optional[Mapping[str, Any]] = None,\n    edge_attr: Optional[Mapping[str, Any]] = None,\n) -&gt; str\n</code></pre> <p>Generate Graphviz DOT language representation of entity relationship diagram for given data model classes.</p> <p>Parameters:</p> Name Type Description Default <code>graph_attr</code> <code>Mapping[str, Any] | None</code> <p>Override any graph attributes on the <code>pygraphviz.AGraph</code> instance. Defaults to None.</p> <code>None</code> <code>node_attr</code> <code>Mapping[str, Any] | None</code> <p>Override any node attributes for all nodes on the <code>pygraphviz.AGraph</code> instance. Defaults to None.</p> <code>None</code> <code>edge_attr</code> <code>Mapping[str, Any] | None</code> <p>Override any edge attributes for all edges on the <code>pygraphviz.AGraph</code> instance. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>DOT language representation of diagram</p> Source code in <code>erdantic/core.py</code> <pre><code>def to_dot(\n    self,\n    graph_attr: Optional[Mapping[str, Any]] = None,\n    node_attr: Optional[Mapping[str, Any]] = None,\n    edge_attr: Optional[Mapping[str, Any]] = None,\n) -&gt; str:\n    \"\"\"Generate Graphviz [DOT language](https://graphviz.org/doc/info/lang.html) representation\n    of entity relationship diagram for given data model classes.\n\n    Args:\n        graph_attr (Mapping[str, Any] | None, optional): Override any graph attributes on\n            the `pygraphviz.AGraph` instance. Defaults to None.\n        node_attr (Mapping[str, Any] | None, optional): Override any node attributes for all\n            nodes on the `pygraphviz.AGraph` instance. Defaults to None.\n        edge_attr (Mapping[str, Any] | None, optional): Override any edge attributes for all\n            edges on the `pygraphviz.AGraph` instance. Defaults to None.\n\n    Returns:\n        str: DOT language representation of diagram\n    \"\"\"\n    return self.to_graphviz(\n        graph_attr=graph_attr,\n        node_attr=node_attr,\n        edge_attr=edge_attr,\n    ).string()\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.EntityRelationshipDiagram.to_graphviz","title":"to_graphviz","text":"<pre><code>to_graphviz(\n    graph_attr: Optional[Mapping[str, Any]] = None,\n    node_attr: Optional[Mapping[str, Any]] = None,\n    edge_attr: Optional[Mapping[str, Any]] = None,\n) -&gt; AGraph\n</code></pre> <p>Return <code>pygraphviz.AGraph</code> instance for diagram.</p> <p>Parameters:</p> Name Type Description Default <code>graph_attr</code> <code>Mapping[str, Any] | None</code> <p>Override any graph attributes on the <code>pygraphviz.AGraph</code> instance. Defaults to None.</p> <code>None</code> <code>node_attr</code> <code>Mapping[str, Any] | None</code> <p>Override any node attributes for all nodes on the <code>pygraphviz.AGraph</code> instance. Defaults to None.</p> <code>None</code> <code>edge_attr</code> <code>Mapping[str, Any] | None</code> <p>Override any edge attributes for all edges on the <code>pygraphviz.AGraph</code> instance. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>AGraph</code> <p>graph object for diagram</p> Source code in <code>erdantic/core.py</code> <pre><code>def to_graphviz(\n    self,\n    graph_attr: Optional[Mapping[str, Any]] = None,\n    node_attr: Optional[Mapping[str, Any]] = None,\n    edge_attr: Optional[Mapping[str, Any]] = None,\n) -&gt; pgv.AGraph:\n    \"\"\"Return [`pygraphviz.AGraph`][pygraphviz.agraph.AGraph] instance for diagram.\n\n    Args:\n        graph_attr (Mapping[str, Any] | None, optional): Override any graph attributes on\n            the `pygraphviz.AGraph` instance. Defaults to None.\n        node_attr (Mapping[str, Any] | None, optional): Override any node attributes for all\n            nodes on the `pygraphviz.AGraph` instance. Defaults to None.\n        edge_attr (Mapping[str, Any] | None, optional): Override any edge attributes for all\n            edges on the `pygraphviz.AGraph` instance. Defaults to None.\n\n    Returns:\n        pygraphviz.AGraph: graph object for diagram\n    \"\"\"\n    g = pgv.AGraph(\n        name=\"Entity Relationship Diagram created by erdantic\",\n        directed=True,\n        strict=False,\n    )\n    g.graph_attr.update(DEFAULT_GRAPH_ATTR)\n    g.graph_attr.update(graph_attr or {})\n    g.node_attr.update(DEFAULT_NODE_ATTR)\n    g.node_attr.update(node_attr or {})\n    g.edge_attr.update(DEFAULT_EDGE_ATTR)\n    g.edge_attr.update(edge_attr or {})\n    for full_name, model_info in self.models.items():\n        g.add_node(\n            full_name,\n            label=model_info.to_dot_label(),\n            tooltip=model_info.description.replace(\"\\n\", \"&amp;#xA;\"),\n        )\n    for edge in self.edges.values():\n        g.add_edge(\n            edge.source_model_full_name,\n            edge.target_model_full_name,\n            tailport=f\"{edge.source_field_name}:e\",\n            headport=\"_root:w\",\n            arrowhead=edge.target_dot_arrow_shape(),\n            arrowtail=edge.source_dot_arrow_shape(),\n        )\n    return g\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.FieldInfo","title":"FieldInfo","text":"<p>             Bases: <code>BaseModel</code></p> <p>Holds information about a field of an analyzed data model class.</p> <p>Attributes:</p> Name Type Description <code>model_full_name</code> <code>FullyQualifiedName</code> <p>Fully qualified name of the data model class that the field belongs to.</p> <code>name</code> <code>str</code> <p>Name of the field.</p> <code>type_name</code> <code>str</code> <p>String representation of the field's type.</p> Source code in <code>erdantic/core.py</code> <pre><code>@add_repr_pretty_to_pydantic\nclass FieldInfo(pydantic.BaseModel):\n    \"\"\"Holds information about a field of an analyzed data model class.\n\n    Attributes:\n        model_full_name (FullyQualifiedName): Fully qualified name of the data model class that\n            the field belongs to.\n        name (str): Name of the field.\n        type_name (str): String representation of the field's type.\n    \"\"\"\n\n    model_full_name: FullyQualifiedName\n    name: str\n    type_name: str\n\n    model_config = pydantic.ConfigDict(\n        extra=\"forbid\",\n        protected_namespaces=(),\n    )\n\n    _dot_row_template = \"\"\"&lt;tr&gt;&lt;td&gt;{name}&lt;/td&gt;&lt;td port=\"{name}\"&gt;{type_name}&lt;/td&gt;&lt;/tr&gt;\"\"\"\n\n    _raw_type: Optional[type] = pydantic.PrivateAttr(None)\n\n    @classmethod\n    def from_raw_type(cls, model_full_name: FullyQualifiedName, name: str, raw_type: type) -&gt; Self:\n        \"\"\"Constructor method to create a new instance from a raw type annotation.\n\n        Args:\n            model_full_name (FullyQualifiedName): Fully qualified name of the data model class that\n                the field belongs to.\n            name (str): Name of field.\n            raw_type (type): Type annotation.\n\n        Returns:\n            Self: _description_\n        \"\"\"\n        if get_origin(raw_type) is Annotated:\n            # Drop the Annotated extra metadata for the string representation\n            type_name = typenames(get_args(raw_type)[0], remove_modules=REMOVE_ALL_MODULES)\n        else:\n            type_name = typenames(raw_type, remove_modules=REMOVE_ALL_MODULES)\n        field_info = cls(\n            model_full_name=model_full_name,\n            name=name,\n            type_name=type_name,\n        )\n        field_info._raw_type = raw_type\n        return field_info\n\n    @property\n    def key(self) -&gt; str:\n        \"\"\"Returns the key used to identify this instance of FieldInfo in the ModelInfo.fields\n        mapping. This value is the value in the 'name' field.\n        \"\"\"\n        return self.name\n\n    @property\n    def raw_type(self) -&gt; type:\n        \"\"\"Returns the raw type annotation of the field. This is a cached property. If the raw\n        type is not already known, it will attempt to import the data model class and reextract\n        the field's type annotation.\n\n        Raises:\n            FieldNotFoundError: _description_\n            UnknownModelTypeError: _description_\n\n        Returns:\n            type: Type annotation.\n        \"\"\"\n        if self._raw_type is None:\n            model = self.model_full_name.import_object()\n            get_fields_fn = identify_field_extractor_fn(model)\n            if get_fields_fn:\n                for field_info in get_fields_fn(model):\n                    if field_info.name == self.name:\n                        self._raw_type = field_info.raw_type\n                        break\n                else:\n                    raise FieldNotFoundError(\n                        name=self.name, obj=model, model_full_name=self.model_full_name\n                    )\n            else:\n                raise UnknownModelTypeError(model=model, available_plugins=list_plugins())\n        return self._raw_type\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if not isinstance(other, FieldInfo):\n            return NotImplemented\n        return self.model_dump() == other.model_dump()\n\n    def to_dot_row(self) -&gt; str:\n        \"\"\"Returns the DOT language \"HTML-like\" syntax specification of a row detailing this field\n        that is part of a table describing the field's parent data model. It is used as part the\n        `label` attribute of data model's node in the graph's DOT representation.\n\n        Returns:\n            str: DOT language for table row\n        \"\"\"\n        return self._dot_row_template.format(name=self.name, type_name=self.type_name)\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.FieldInfo.key","title":"key  <code>property</code>","text":"<pre><code>key: str\n</code></pre> <p>Returns the key used to identify this instance of FieldInfo in the ModelInfo.fields mapping. This value is the value in the 'name' field.</p>"},{"location":"api-reference/core/#erdantic.core.FieldInfo.raw_type","title":"raw_type  <code>property</code>","text":"<pre><code>raw_type: type\n</code></pre> <p>Returns the raw type annotation of the field. This is a cached property. If the raw type is not already known, it will attempt to import the data model class and reextract the field's type annotation.</p> <p>Raises:</p> Type Description <code>FieldNotFoundError</code> <p>description</p> <code>UnknownModelTypeError</code> <p>description</p> <p>Returns:</p> Type Description <code>type</code> <p>Type annotation.</p>"},{"location":"api-reference/core/#erdantic.core.FieldInfo.from_raw_type","title":"from_raw_type  <code>classmethod</code>","text":"<pre><code>from_raw_type(\n    model_full_name: FullyQualifiedName,\n    name: str,\n    raw_type: type,\n) -&gt; Self\n</code></pre> <p>Constructor method to create a new instance from a raw type annotation.</p> <p>Parameters:</p> Name Type Description Default <code>model_full_name</code> <code>FullyQualifiedName</code> <p>Fully qualified name of the data model class that the field belongs to.</p> required <code>name</code> <code>str</code> <p>Name of field.</p> required <code>raw_type</code> <code>type</code> <p>Type annotation.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>description</p> Source code in <code>erdantic/core.py</code> <pre><code>@classmethod\ndef from_raw_type(cls, model_full_name: FullyQualifiedName, name: str, raw_type: type) -&gt; Self:\n    \"\"\"Constructor method to create a new instance from a raw type annotation.\n\n    Args:\n        model_full_name (FullyQualifiedName): Fully qualified name of the data model class that\n            the field belongs to.\n        name (str): Name of field.\n        raw_type (type): Type annotation.\n\n    Returns:\n        Self: _description_\n    \"\"\"\n    if get_origin(raw_type) is Annotated:\n        # Drop the Annotated extra metadata for the string representation\n        type_name = typenames(get_args(raw_type)[0], remove_modules=REMOVE_ALL_MODULES)\n    else:\n        type_name = typenames(raw_type, remove_modules=REMOVE_ALL_MODULES)\n    field_info = cls(\n        model_full_name=model_full_name,\n        name=name,\n        type_name=type_name,\n    )\n    field_info._raw_type = raw_type\n    return field_info\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.FieldInfo.to_dot_row","title":"to_dot_row","text":"<pre><code>to_dot_row() -&gt; str\n</code></pre> <p>Returns the DOT language \"HTML-like\" syntax specification of a row detailing this field that is part of a table describing the field's parent data model. It is used as part the <code>label</code> attribute of data model's node in the graph's DOT representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>DOT language for table row</p> Source code in <code>erdantic/core.py</code> <pre><code>def to_dot_row(self) -&gt; str:\n    \"\"\"Returns the DOT language \"HTML-like\" syntax specification of a row detailing this field\n    that is part of a table describing the field's parent data model. It is used as part the\n    `label` attribute of data model's node in the graph's DOT representation.\n\n    Returns:\n        str: DOT language for table row\n    \"\"\"\n    return self._dot_row_template.format(name=self.name, type_name=self.type_name)\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.FullyQualifiedName","title":"FullyQualifiedName","text":"<p>             Bases: <code>BaseModel</code></p> <p>Holds the fully qualified name components (module and qualified name) of a Python object. This is used to uniquely identify an object, can be used to import it.</p> <p>Attributes:</p> Name Type Description <code>module</code> <code>str</code> <p>Name of the module that the object is defined in.</p> <code>qual_name</code> <code>str</code> <p>Qualified name of the object.</p> Source code in <code>erdantic/core.py</code> <pre><code>@total_ordering\nclass FullyQualifiedName(pydantic.BaseModel):\n    \"\"\"Holds the fully qualified name components (module and qualified name) of a Python object.\n    This is used to uniquely identify an object, can be used to import it.\n\n    Attributes:\n        module (str): Name of the module that the object is defined in.\n        qual_name (str): Qualified name of the object.\n    \"\"\"\n\n    module: str\n    qual_name: str\n\n    @classmethod\n    def from_object(cls, obj: Any) -&gt; Self:\n        \"\"\"Constructor method to create a new instance from a Python object.\n\n        Args:\n            obj (Any): Python object.\n\n        Returns:\n            Self: Fully qualified name of the object.\n        \"\"\"\n        return cls(module=obj.__module__, qual_name=obj.__qualname__)\n\n    def __hash__(self) -&gt; int:\n        return hash((self.module, self.qual_name))\n\n    def __str__(self) -&gt; str:\n        return f\"{self.module}.{self.qual_name}\"\n\n    def import_object(self) -&gt; Any:\n        \"\"\"Imports the object from the module and returns it.\n\n        Returns:\n            Any: Object referenced by this FullyQualifiedName instance.\n        \"\"\"\n        module = import_module(self.module)\n        obj = module\n        for name in self.qual_name.split(\".\"):\n            obj = getattr(obj, name)\n        return obj\n\n    def __lt__(self, other: Self) -&gt; bool:\n        if not isinstance(other, FullyQualifiedName):\n            return NotImplemented\n        return (self.module, self.qual_name) &lt; (other.module, other.qual_name)\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.FullyQualifiedName.from_object","title":"from_object  <code>classmethod</code>","text":"<pre><code>from_object(obj: Any) -&gt; Self\n</code></pre> <p>Constructor method to create a new instance from a Python object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>Python object.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Fully qualified name of the object.</p> Source code in <code>erdantic/core.py</code> <pre><code>@classmethod\ndef from_object(cls, obj: Any) -&gt; Self:\n    \"\"\"Constructor method to create a new instance from a Python object.\n\n    Args:\n        obj (Any): Python object.\n\n    Returns:\n        Self: Fully qualified name of the object.\n    \"\"\"\n    return cls(module=obj.__module__, qual_name=obj.__qualname__)\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.FullyQualifiedName.import_object","title":"import_object","text":"<pre><code>import_object() -&gt; Any\n</code></pre> <p>Imports the object from the module and returns it.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Object referenced by this FullyQualifiedName instance.</p> Source code in <code>erdantic/core.py</code> <pre><code>def import_object(self) -&gt; Any:\n    \"\"\"Imports the object from the module and returns it.\n\n    Returns:\n        Any: Object referenced by this FullyQualifiedName instance.\n    \"\"\"\n    module = import_module(self.module)\n    obj = module\n    for name in self.qual_name.split(\".\"):\n        obj = getattr(obj, name)\n    return obj\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.Modality","title":"Modality","text":"<p>             Bases: <code>Enum</code></p> <p>Enumeration of possible modality values for a relationship between two data model classes. Modality measures the minimum number of associations.</p> Source code in <code>erdantic/core.py</code> <pre><code>class Modality(Enum):\n    \"\"\"Enumeration of possible modality values for a relationship between two data model\n    classes. Modality measures the minimum number of associations.\n    \"\"\"\n\n    UNSPECIFIED = \"unspecified\"\n    ZERO = \"zero\"\n    ONE = \"one\"\n\n    def to_dot(self) -&gt; str:\n        \"\"\"Returns the DOT language specification for the arrowhead styling associated with the\n        modality value.\n        \"\"\"\n        return _MODALITY_DOT_MAPPING[self]\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.Modality.to_dot","title":"to_dot","text":"<pre><code>to_dot() -&gt; str\n</code></pre> <p>Returns the DOT language specification for the arrowhead styling associated with the modality value.</p> Source code in <code>erdantic/core.py</code> <pre><code>def to_dot(self) -&gt; str:\n    \"\"\"Returns the DOT language specification for the arrowhead styling associated with the\n    modality value.\n    \"\"\"\n    return _MODALITY_DOT_MAPPING[self]\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.ModelInfo","title":"ModelInfo","text":"<p>             Bases: <code>BaseModel</code>, <code>Generic[_ModelType]</code></p> <p>Holds information about an analyzed data model class.</p> <p>Attributes:</p> Name Type Description <code>full_name</code> <code>FullyQualifiedName</code> <p>Fully qualified name of the data model class.</p> <code>name</code> <code>str</code> <p>Name of the data model class.</p> <code>fields</code> <code>Dict[str, FieldInfo]</code> <p>A mapping to FieldInfo instances for each field of the data model class.</p> <code>description</code> <code>str</code> <p>Docstring or other description of the data model class.</p> Source code in <code>erdantic/core.py</code> <pre><code>@add_repr_pretty_to_pydantic\nclass ModelInfo(pydantic.BaseModel, Generic[_ModelType]):\n    \"\"\"Holds information about an analyzed data model class.\n\n    Attributes:\n        full_name (FullyQualifiedName): Fully qualified name of the data model class.\n        name (str): Name of the data model class.\n        fields (Dict[str, FieldInfo]): A mapping to FieldInfo instances for each field of the data\n            model class.\n        description (str): Docstring or other description of the data model class.\n    \"\"\"\n\n    full_name: FullyQualifiedName\n    name: str\n    fields: Dict[str, FieldInfo]\n    description: str = \"\"\n\n    model_config = pydantic.ConfigDict(\n        extra=\"forbid\",\n    )\n\n    _dot_table_template = textwrap.dedent(\n        \"\"\"\\\n        &lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;\n        &lt;tr&gt;&lt;td port=\"_root\" colspan=\"{num_cols}\"&gt;&lt;b&gt;{name}&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;\n        {rows}\n        &lt;/table&gt;&gt;\n        \"\"\"\n    )\n\n    _raw_model: Optional[_ModelType] = pydantic.PrivateAttr(None)\n\n    @classmethod\n    def from_raw_model(cls, raw_model: _ModelType) -&gt; Self:\n        \"\"\"Constructor method to create a new instance from a raw data model class.\n\n        Args:\n            raw_model (type): Data model class.\n\n        Returns:\n            Self: New instance of ModelInfo.\n        \"\"\"\n        get_fields_fn = identify_field_extractor_fn(raw_model)\n        if not get_fields_fn:\n            raise UnknownModelTypeError(model=raw_model, available_plugins=list_plugins())\n\n        full_name = FullyQualifiedName.from_object(raw_model)\n        description = str(full_name)\n        docstring = inspect.getdoc(raw_model)\n        if docstring:\n            description += \"\\n\\n\" + docstring + \"\\n\"\n\n        model_info = cls(\n            full_name=full_name,\n            name=raw_model.__name__,\n            fields={field_info.name: field_info for field_info in get_fields_fn(raw_model)},\n            description=description,\n        )\n        model_info._raw_model = raw_model\n        return model_info\n\n    @property\n    def key(self) -&gt; str:\n        \"\"\"Returns the key used to identify this instance of ModelInfo in the\n        EntityRelationshipDiagram.models mapping. This value is the string representation of the\n        `full_name` field.\n        \"\"\"\n        return str(self.full_name)\n\n    @property\n    def raw_model(self) -&gt; _ModelType:\n        \"\"\"Returns the raw data model class. This is a cached property. If the raw model is not\n        already known, it will attempt to import the data model class.\n        \"\"\"\n        if self._raw_model is None:\n            self._raw_model = self.full_name.import_object()\n        return self._raw_model\n\n    def __eq__(self, other: Any) -&gt; bool:\n        if not isinstance(other, ModelInfo):\n            return NotImplemented\n        return self.model_dump() == other.model_dump()\n\n    def to_dot_label(self) -&gt; str:\n        \"\"\"Returns the DOT language \"HTML-like\" syntax specification of a table for this data\n        model. It is used as the `label` attribute of data model's node in the graph's DOT\n        representation.\n\n        Returns:\n            str: DOT language for table\n        \"\"\"\n        # Get number of columns dynamically from first row\n        num_cols = next(iter(self.fields.values())).to_dot_row().count(\"&lt;td\")\n        # Concatenate DOT of all rows together\n        rows = \"\\n\".join(field_info.to_dot_row() for field_info in self.fields.values()) + \"\\n\"\n        return self._dot_table_template.format(\n            name=self.name, num_cols=num_cols, rows=rows\n        ).replace(\"\\n\", \"\")\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.ModelInfo.key","title":"key  <code>property</code>","text":"<pre><code>key: str\n</code></pre> <p>Returns the key used to identify this instance of ModelInfo in the EntityRelationshipDiagram.models mapping. This value is the string representation of the <code>full_name</code> field.</p>"},{"location":"api-reference/core/#erdantic.core.ModelInfo.raw_model","title":"raw_model  <code>property</code>","text":"<pre><code>raw_model: _ModelType\n</code></pre> <p>Returns the raw data model class. This is a cached property. If the raw model is not already known, it will attempt to import the data model class.</p>"},{"location":"api-reference/core/#erdantic.core.ModelInfo.from_raw_model","title":"from_raw_model  <code>classmethod</code>","text":"<pre><code>from_raw_model(raw_model: _ModelType) -&gt; Self\n</code></pre> <p>Constructor method to create a new instance from a raw data model class.</p> <p>Parameters:</p> Name Type Description Default <code>raw_model</code> <code>type</code> <p>Data model class.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>New instance of ModelInfo.</p> Source code in <code>erdantic/core.py</code> <pre><code>@classmethod\ndef from_raw_model(cls, raw_model: _ModelType) -&gt; Self:\n    \"\"\"Constructor method to create a new instance from a raw data model class.\n\n    Args:\n        raw_model (type): Data model class.\n\n    Returns:\n        Self: New instance of ModelInfo.\n    \"\"\"\n    get_fields_fn = identify_field_extractor_fn(raw_model)\n    if not get_fields_fn:\n        raise UnknownModelTypeError(model=raw_model, available_plugins=list_plugins())\n\n    full_name = FullyQualifiedName.from_object(raw_model)\n    description = str(full_name)\n    docstring = inspect.getdoc(raw_model)\n    if docstring:\n        description += \"\\n\\n\" + docstring + \"\\n\"\n\n    model_info = cls(\n        full_name=full_name,\n        name=raw_model.__name__,\n        fields={field_info.name: field_info for field_info in get_fields_fn(raw_model)},\n        description=description,\n    )\n    model_info._raw_model = raw_model\n    return model_info\n</code></pre>"},{"location":"api-reference/core/#erdantic.core.ModelInfo.to_dot_label","title":"to_dot_label","text":"<pre><code>to_dot_label() -&gt; str\n</code></pre> <p>Returns the DOT language \"HTML-like\" syntax specification of a table for this data model. It is used as the <code>label</code> attribute of data model's node in the graph's DOT representation.</p> <p>Returns:</p> Type Description <code>str</code> <p>DOT language for table</p> Source code in <code>erdantic/core.py</code> <pre><code>def to_dot_label(self) -&gt; str:\n    \"\"\"Returns the DOT language \"HTML-like\" syntax specification of a table for this data\n    model. It is used as the `label` attribute of data model's node in the graph's DOT\n    representation.\n\n    Returns:\n        str: DOT language for table\n    \"\"\"\n    # Get number of columns dynamically from first row\n    num_cols = next(iter(self.fields.values())).to_dot_row().count(\"&lt;td\")\n    # Concatenate DOT of all rows together\n    rows = \"\\n\".join(field_info.to_dot_row() for field_info in self.fields.values()) + \"\\n\"\n    return self._dot_table_template.format(\n        name=self.name, num_cols=num_cols, rows=rows\n    ).replace(\"\\n\", \"\")\n</code></pre>"},{"location":"api-reference/exceptions/","title":"erdantic.exceptions","text":""},{"location":"api-reference/exceptions/#erdantic.exceptions.ErdanticException","title":"ErdanticException","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for all exceptions from erdantic library.</p> Source code in <code>erdantic/exceptions.py</code> <pre><code>class ErdanticException(Exception):\n    \"\"\"Base class for all exceptions from erdantic library.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#erdantic.exceptions.FieldNotFoundError","title":"FieldNotFoundError","text":"<p>             Bases: <code>AttributeError</code>, <code>ErdanticException</code></p> <p>Raised trying to access a field name that does not match any fields returned by the field extractor function for a model.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the field that was not found.</p> <code>obj</code> <code>object</code> <p>The model object that the field was being accessed on.</p> <code>model_full_name</code> <code>FullyQualifiedName</code> <p>The fully qualified name of the model.</p> Source code in <code>erdantic/exceptions.py</code> <pre><code>class FieldNotFoundError(AttributeError, ErdanticException):\n    \"\"\"Raised trying to access a field name that does not match any fields returned by the\n    field extractor function for a model.\n\n    Attributes:\n        name (str): The name of the field that was not found.\n        obj (object): The model object that the field was being accessed on.\n        model_full_name (FullyQualifiedName): The fully qualified name of the model.\n    \"\"\"\n\n    def __init__(self, *args, name: str, obj: object, model_full_name: \"FullyQualifiedName\"):\n        self.model_full_name = model_full_name\n        msg = f\"Model '{model_full_name}' has no field '{name}'.\"\n        if sys.version_info &gt;= (3, 10):\n            super().__init__(*args, msg, name=name, obj=obj)\n        else:\n            self.name = name\n            self.obj = obj\n            super().__init__(*args, msg)\n</code></pre>"},{"location":"api-reference/exceptions/#erdantic.exceptions.ModelOrModuleNotFoundError","title":"ModelOrModuleNotFoundError","text":"<p>             Bases: <code>ImportError</code>, <code>ErdanticException</code></p> <p>Raised when specified fully qualified name of model class or module cannot be imported.</p> Source code in <code>erdantic/exceptions.py</code> <pre><code>class ModelOrModuleNotFoundError(ImportError, ErdanticException):\n    \"\"\"Raised when specified fully qualified name of model class or module cannot be imported.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#erdantic.exceptions.PluginNotFoundError","title":"PluginNotFoundError","text":"<p>             Bases: <code>KeyError</code>, <code>ErdanticException</code></p> <p>Raised when specified plugin key does not match a registered plugin.</p> <p>Attributes:</p> Name Type Description <code>key</code> <code>str</code> <p>The plugin key that was not found.</p> Source code in <code>erdantic/exceptions.py</code> <pre><code>class PluginNotFoundError(KeyError, ErdanticException):\n    \"\"\"Raised when specified plugin key does not match a registered plugin.\n\n    Attributes:\n        key (str): The plugin key that was not found.\n    \"\"\"\n\n    def __init__(self, *args: object, key: str) -&gt; None:\n        self.key = key\n        message = f\"Specified plugin not found: '{key}'\"\n        super().__init__(*args, message)\n</code></pre>"},{"location":"api-reference/exceptions/#erdantic.exceptions.UnevaluatedForwardRefError","title":"UnevaluatedForwardRefError","text":"<p>             Bases: <code>ErdanticException</code></p> <p>Raised when a field's type declaration has an unevaluated forward reference.</p> <p>Attributes:</p> Name Type Description <code>model_full_name</code> <code>FullyQualifiedName</code> <p>The fully qualified name of the model with the field with the unevaluated forward reference.</p> <code>field_name</code> <code>str</code> <p>The name of the field with the unevaluated forward reference.</p> <code>forward_ref</code> <code>str</code> <p>The string representation of the unevaluated forward reference.</p> Source code in <code>erdantic/exceptions.py</code> <pre><code>class UnevaluatedForwardRefError(ErdanticException):\n    \"\"\"Raised when a field's type declaration has an unevaluated forward reference.\n\n    Attributes:\n        model_full_name (FullyQualifiedName): The fully qualified name of the model with the field\n            with the unevaluated forward reference.\n        field_name (str): The name of the field with the unevaluated forward reference.\n        forward_ref (str): The string representation of the unevaluated forward reference.\n    \"\"\"\n\n    def __init__(\n        self,\n        *args: object,\n        model_full_name: \"FullyQualifiedName\",\n        field_name: str,\n        forward_ref: str,\n    ) -&gt; None:\n        self.model_full_name = model_full_name\n        self.field_name = field_name\n        self.forward_ref = forward_ref\n        message = (\n            f\"Unevaluated forward reference '{forward_ref}' \"\n            f\"for field '{field_name}' on model '{model_full_name}'. \"\n            \"Normally, erdantic plugins try to resolve forward references automatically, and this \"\n            \"error indicates that this didn't happen. If you are using a built-in plugin, please \"\n            \"report this as a bug. If you are using a custom or third-party plugin, then that \"\n            \"plugin needs to add support for automatically resolving forward references. \"\n        )\n        super().__init__(*args, message)\n</code></pre>"},{"location":"api-reference/exceptions/#erdantic.exceptions.UnknownModelTypeError","title":"UnknownModelTypeError","text":"<p>             Bases: <code>ValueError</code>, <code>ErdanticException</code></p> <p>Raised when a given model does not match known model types from loaded plugins.</p> <p>Attributes:</p> Name Type Description <code>model</code> <code>type</code> <p>The model class that was not recognized.</p> <code>available_plugins</code> <code>List[str]</code> <p>List of plugin keys that were available.</p> Source code in <code>erdantic/exceptions.py</code> <pre><code>class UnknownModelTypeError(ValueError, ErdanticException):\n    \"\"\"Raised when a given model does not match known model types from loaded plugins.\n\n    Attributes:\n        model (type): The model class that was not recognized.\n        available_plugins (List[str]): List of plugin keys that were available.\n    \"\"\"\n\n    def __init__(self, *args, model: type, available_plugins: List[str]):\n        mro = getattr(model, \"__mro__\", str(model))\n        message = (\n            \"Given model does not match any supported types. \"\n            f\"Available plugins: {available_plugins}. \"\n            f\"Model MRO: {mro}\"\n        )\n        self.model = model\n        self.available_plugins = available_plugins\n        super().__init__(*args, message)\n</code></pre>"},{"location":"api-reference/exceptions/#erdantic.exceptions.UnresolvableForwardRefError","title":"UnresolvableForwardRefError","text":"<p>             Bases: <code>NameError</code>, <code>ErdanticException</code></p> <p>Raised when a forward reference in a type annotation cannot be resolved automatically.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The string representation of the unresolvable forward reference.</p> Source code in <code>erdantic/exceptions.py</code> <pre><code>class UnresolvableForwardRefError(NameError, ErdanticException):\n    \"\"\"Raised when a forward reference in a type annotation cannot be resolved automatically.\n\n    Attributes:\n        name (str): The string representation of the unresolvable forward reference.\n    \"\"\"\n\n    def __init__(\n        self,\n        *args: object,\n        name: str,\n        model_full_name: \"FullyQualifiedName\",\n    ) -&gt; None:\n        self.model_full_name = model_full_name\n        if sys.version_info &gt;= (3, 10):\n            # typeshed is wrong; NameError does have keyword argument 'name'\n            super().__init__(*args, name=name)  # type: ignore [call-arg]\n        else:\n            super().__init__(*args)\n            self.name = name\n</code></pre>"},{"location":"api-reference/typing_utils/","title":"erdantic.typing_utils","text":""},{"location":"api-reference/typing_utils/#erdantic.typing_utils.get_depth1_bases","title":"get_depth1_bases","text":"<pre><code>get_depth1_bases(tp: type) -&gt; List[type]\n</code></pre> <p>Returns depth-1 base classes of a type.</p> Source code in <code>erdantic/typing_utils.py</code> <pre><code>def get_depth1_bases(tp: type) -&gt; List[type]:\n    \"\"\"Returns depth-1 base classes of a type.\"\"\"\n    bases_of_bases = {bb for b in tp.__mro__[1:] for bb in b.__mro__[1:]}\n    return [b for b in tp.__mro__[1:] if b not in bases_of_bases]\n</code></pre>"},{"location":"api-reference/typing_utils/#erdantic.typing_utils.get_recursive_args","title":"get_recursive_args","text":"<pre><code>get_recursive_args(tp: _TypeForm) -&gt; List[_TypeForm]\n</code></pre> <p>Recursively finds leaf-node types of possibly-nested generic type.</p> Source code in <code>erdantic/typing_utils.py</code> <pre><code>def get_recursive_args(tp: _TypeForm) -&gt; List[_TypeForm]:\n    \"\"\"Recursively finds leaf-node types of possibly-nested generic type.\"\"\"\n\n    def recurse(t: _TypeForm) -&gt; Iterator[_TypeForm]:\n        if isinstance(t, str):\n            raise _UnevaluatedForwardRefError(forward_ref=t)\n        elif isinstance(t, ForwardRef):\n            if t.__forward_evaluated__:\n                t = t.__forward_value__  # type: ignore [assignment]\n            else:\n                raise _UnevaluatedForwardRefError(forward_ref=t.__forward_arg__)\n\n        if get_origin(t) is Literal:\n            yield t\n            return\n\n        args = get_args(t)\n        if args:\n            for arg in args:\n                yield from recurse(arg)\n        else:\n            yield t\n\n    return list(recurse(tp))\n</code></pre>"},{"location":"api-reference/typing_utils/#erdantic.typing_utils.is_collection_type_of","title":"is_collection_type_of","text":"<pre><code>is_collection_type_of(tp: _TypeForm, target: type) -&gt; bool\n</code></pre> <p>Given a type annotation, returns True if it represents a collection of many elements of the target type.</p> <p>Parameters:</p> Name Type Description Default <code>tp</code> <code>Union[type, GenericAlias]</code> <p>Type annotation.</p> required <code>target</code> <code>type</code> <p>Type to check for many-ness of.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Result of check.</p> Source code in <code>erdantic/typing_utils.py</code> <pre><code>def is_collection_type_of(tp: _TypeForm, target: type) -&gt; bool:\n    \"\"\"Given a type annotation, returns True if it represents a collection of many elements of the\n    target type.\n\n    Args:\n        tp (Union[type, GenericAlias]): Type annotation.\n        target (type): Type to check for many-ness of.\n\n    Returns:\n        bool: Result of check.\n    \"\"\"\n    root = parse_type_tree(tp)\n    return _walk_type_tree(root, target)\n</code></pre>"},{"location":"api-reference/typing_utils/#erdantic.typing_utils.is_nullable_type","title":"is_nullable_type","text":"<pre><code>is_nullable_type(tp: _TypeForm) -&gt; bool\n</code></pre> <p>Given a type annotation, returns True if it is a union with None as a possible option, such as typing.Optional.</p> <p>Parameters:</p> Name Type Description Default <code>tp</code> <code>Union[type, GenericAlias]</code> <p>Type annotation.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Result of check.</p> Source code in <code>erdantic/typing_utils.py</code> <pre><code>def is_nullable_type(tp: _TypeForm) -&gt; bool:\n    \"\"\"Given a type annotation, returns True if it is a union with None as a possible option,\n    such as typing.Optional.\n\n    Args:\n        tp (Union[type, GenericAlias]): Type annotation.\n\n    Returns:\n        bool: Result of check.\n    \"\"\"\n    return get_origin(tp) is Union and type(None) in get_args(tp)\n</code></pre>"},{"location":"api-reference/typing_utils/#erdantic.typing_utils.repr_type_with_mro","title":"repr_type_with_mro","text":"<pre><code>repr_type_with_mro(obj: Any) -&gt; str\n</code></pre> <p>Return MRO of object if it has one. Otherwise return its repr.</p> Source code in <code>erdantic/typing_utils.py</code> <pre><code>def repr_type_with_mro(obj: Any) -&gt; str:\n    \"\"\"Return MRO of object if it has one. Otherwise return its repr.\"\"\"\n\n    def _full_name(tp: type) -&gt; str:\n        module = tp.__module__\n        return f\"{module}.{tp.__qualname__}\".replace(\"builtins.\", \"\")\n\n    if hasattr(obj, \"__mro__\"):\n        mro = \", \".join(_full_name(m) for m in obj.__mro__)\n        return f\"&lt;mro ({mro})&gt;\"\n    return repr(obj)\n</code></pre>"},{"location":"api-reference/examples/attrs/","title":"erdantic.examples.attrs","text":"<p>Example data model classes using standard library's <code>dataclasses</code> module.</p>"},{"location":"api-reference/examples/attrs/#erdantic.examples.attrs.Adventurer","title":"Adventurer","text":"<p>A person often late for dinner but with a tale or two to tell.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of this adventurer</p> <code>profession</code> <code>str</code> <p>Profession of this adventurer</p> <code>level</code> <code>int</code> <p>Level of this adventurer</p> <code>alignment</code> <code>Alignment</code> <p>Alignment of this adventurer</p> Source code in <code>erdantic/examples/attrs.py</code> <pre><code>@define\nclass Adventurer:\n    \"\"\"A person often late for dinner but with a tale or two to tell.\n\n    Attributes:\n        name (str): Name of this adventurer\n        profession (str): Profession of this adventurer\n        level (int): Level of this adventurer\n        alignment (Alignment): Alignment of this adventurer\n    \"\"\"\n\n    name: str\n    profession: str\n    alignment: Alignment\n    level: int = 1\n</code></pre>"},{"location":"api-reference/examples/attrs/#erdantic.examples.attrs.Party","title":"Party","text":"<p>A group of adventurers finding themselves doing and saying things altogether unexpected.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name that party is known by</p> <code>formed_datetime</code> <code>datetime</code> <p>Timestamp of when the party was formed</p> <code>members</code> <code>List[Adventurer]</code> <p>Adventurers that belong to this party</p> <code>active_quest</code> <code>Optional[Quest]</code> <p>Current quest that party is actively tackling</p> Source code in <code>erdantic/examples/attrs.py</code> <pre><code>@define\nclass Party:\n    \"\"\"A group of adventurers finding themselves doing and saying things altogether unexpected.\n\n    Attributes:\n        name (str): Name that party is known by\n        formed_datetime (datetime): Timestamp of when the party was formed\n        members (List[Adventurer]): Adventurers that belong to this party\n        active_quest (Optional[Quest]): Current quest that party is actively tackling\n    \"\"\"\n\n    name: str\n    formed_datetime: datetime\n    members: List[Adventurer] = field(factory=list)\n    active_quest: Optional[Quest] = None\n</code></pre>"},{"location":"api-reference/examples/attrs/#erdantic.examples.attrs.Quest","title":"Quest","text":"<p>A task to complete, with some monetary reward.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name by which this quest is referred to</p> <code>giver</code> <code>QuestGiver</code> <p>Person who offered the quest</p> <code>reward_gold</code> <code>int</code> <p>Amount of gold to be rewarded for quest completion</p> Source code in <code>erdantic/examples/attrs.py</code> <pre><code>@define\nclass Quest:\n    \"\"\"A task to complete, with some monetary reward.\n\n    Attributes:\n        name (str): Name by which this quest is referred to\n        giver (QuestGiver): Person who offered the quest\n        reward_gold (int): Amount of gold to be rewarded for quest completion\n    \"\"\"\n\n    name: str\n    giver: QuestGiver\n    reward_gold: int = 100\n</code></pre>"},{"location":"api-reference/examples/attrs/#erdantic.examples.attrs.QuestGiver","title":"QuestGiver","text":"<p>A person who offers a task that needs completing.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of this quest giver</p> <code>faction</code> <code>str</code> <p>Faction that this quest giver belongs to</p> <code>location</code> <code>str</code> <p>Location this quest giver can be found</p> Source code in <code>erdantic/examples/attrs.py</code> <pre><code>@define\nclass QuestGiver:\n    \"\"\"A person who offers a task that needs completing.\n\n    Attributes:\n        name (str): Name of this quest giver\n        faction (str): Faction that this quest giver belongs to\n        location (str): Location this quest giver can be found\n    \"\"\"\n\n    name: str\n    faction: Optional[str] = None\n    location: str = \"Adventurer's Guild\"\n</code></pre>"},{"location":"api-reference/examples/dataclasses/","title":"erdantic.examples.dataclasses","text":"<p>Example data model classes using standard library's <code>dataclasses</code> module.</p>"},{"location":"api-reference/examples/dataclasses/#erdantic.examples.dataclasses.Adventurer","title":"Adventurer  <code>dataclass</code>","text":"<p>A person often late for dinner but with a tale or two to tell.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of this adventurer</p> <code>profession</code> <code>str</code> <p>Profession of this adventurer</p> <code>alignment</code> <code>Alignment</code> <p>Alignment of this adventurer</p> <code>level</code> <code>int</code> <p>Level of this adventurer</p> Source code in <code>erdantic/examples/dataclasses.py</code> <pre><code>@dataclass\nclass Adventurer:\n    \"\"\"A person often late for dinner but with a tale or two to tell.\n\n    Attributes:\n        name (str): Name of this adventurer\n        profession (str): Profession of this adventurer\n        alignment (Alignment): Alignment of this adventurer\n        level (int): Level of this adventurer\n    \"\"\"\n\n    name: str\n    profession: str\n    alignment: Alignment\n    level: int = 1\n</code></pre>"},{"location":"api-reference/examples/dataclasses/#erdantic.examples.dataclasses.Party","title":"Party  <code>dataclass</code>","text":"<p>A group of adventurers finding themselves doing and saying things altogether unexpected.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name that party is known by</p> <code>formed_datetime</code> <code>datetime</code> <p>Timestamp of when the party was formed</p> <code>members</code> <code>List[Adventurer]</code> <p>Adventurers that belong to this party</p> <code>active_quest</code> <code>Optional[Quest]</code> <p>Current quest that party is actively tackling</p> Source code in <code>erdantic/examples/dataclasses.py</code> <pre><code>@dataclass\nclass Party:\n    \"\"\"A group of adventurers finding themselves doing and saying things altogether unexpected.\n\n    Attributes:\n        name (str): Name that party is known by\n        formed_datetime (datetime): Timestamp of when the party was formed\n        members (List[Adventurer]): Adventurers that belong to this party\n        active_quest (Optional[Quest]): Current quest that party is actively tackling\n    \"\"\"\n\n    name: str\n    formed_datetime: datetime\n    members: List[Adventurer] = field(default_factory=list)\n    active_quest: Optional[Quest] = None\n</code></pre>"},{"location":"api-reference/examples/dataclasses/#erdantic.examples.dataclasses.Quest","title":"Quest  <code>dataclass</code>","text":"<p>A task to complete, with some monetary reward.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name by which this quest is referred to</p> <code>giver</code> <code>QuestGiver</code> <p>Person who offered the quest</p> <code>reward_gold</code> <code>int</code> <p>Amount of gold to be rewarded for quest completion</p> Source code in <code>erdantic/examples/dataclasses.py</code> <pre><code>@dataclass\nclass Quest:\n    \"\"\"A task to complete, with some monetary reward.\n\n    Attributes:\n        name (str): Name by which this quest is referred to\n        giver (QuestGiver): Person who offered the quest\n        reward_gold (int): Amount of gold to be rewarded for quest completion\n    \"\"\"\n\n    name: str\n    giver: QuestGiver\n    reward_gold: int = 100\n</code></pre>"},{"location":"api-reference/examples/dataclasses/#erdantic.examples.dataclasses.QuestGiver","title":"QuestGiver  <code>dataclass</code>","text":"<p>A person who offers a task that needs completing.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of this quest giver</p> <code>faction</code> <code>str</code> <p>Faction that this quest giver belongs to</p> <code>location</code> <code>str</code> <p>Location this quest giver can be found</p> Source code in <code>erdantic/examples/dataclasses.py</code> <pre><code>@dataclass\nclass QuestGiver:\n    \"\"\"A person who offers a task that needs completing.\n\n    Attributes:\n        name (str): Name of this quest giver\n        faction (str): Faction that this quest giver belongs to\n        location (str): Location this quest giver can be found\n    \"\"\"\n\n    name: str\n    faction: Optional[str] = None\n    location: str = \"Adventurer's Guild\"\n</code></pre>"},{"location":"api-reference/examples/pydantic/","title":"erdantic.examples.pydantic","text":"<p>Example data model classes using Pydantic.</p>"},{"location":"api-reference/examples/pydantic/#erdantic.examples.pydantic.Adventurer","title":"Adventurer","text":"<p>             Bases: <code>BaseModel</code></p> <p>A person often late for dinner but with a tale or two to tell.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of this adventurer</p> <code>profession</code> <code>str</code> <p>Profession of this adventurer</p> <code>alignment</code> <code>Alignment</code> <p>Alignment of this adventurer</p> <code>level</code> <code>int</code> <p>Level of this adventurer</p> Source code in <code>erdantic/examples/pydantic.py</code> <pre><code>class Adventurer(BaseModel):\n    \"\"\"A person often late for dinner but with a tale or two to tell.\n\n    Attributes:\n        name (str): Name of this adventurer\n        profession (str): Profession of this adventurer\n        alignment (Alignment): Alignment of this adventurer\n        level (int): Level of this adventurer\n    \"\"\"\n\n    name: str\n    profession: str\n    alignment: Alignment\n    level: int = 1\n</code></pre>"},{"location":"api-reference/examples/pydantic/#erdantic.examples.pydantic.Party","title":"Party","text":"<p>             Bases: <code>BaseModel</code></p> <p>A group of adventurers finding themselves doing and saying things altogether unexpected.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name that party is known by</p> <code>formed_datetime</code> <code>datetime</code> <p>Timestamp of when the party was formed</p> <code>members</code> <code>List[Adventurer]</code> <p>Adventurers that belong to this party</p> <code>active_quest</code> <code>Optional[Quest]</code> <p>Current quest that party is actively tackling</p> Source code in <code>erdantic/examples/pydantic.py</code> <pre><code>class Party(BaseModel):\n    \"\"\"A group of adventurers finding themselves doing and saying things altogether unexpected.\n\n    Attributes:\n        name (str): Name that party is known by\n        formed_datetime (datetime): Timestamp of when the party was formed\n        members (List[Adventurer]): Adventurers that belong to this party\n        active_quest (Optional[Quest]): Current quest that party is actively tackling\n    \"\"\"\n\n    name: str\n    formed_datetime: datetime\n    members: List[Adventurer] = []\n    active_quest: Optional[Quest] = None\n</code></pre>"},{"location":"api-reference/examples/pydantic/#erdantic.examples.pydantic.Quest","title":"Quest","text":"<p>             Bases: <code>BaseModel</code></p> <p>A task to complete, with some monetary reward.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name by which this quest is referred to</p> <code>giver</code> <code>QuestGiver</code> <p>Person who offered the quest</p> <code>reward_gold</code> <code>int</code> <p>Amount of gold to be rewarded for quest completion</p> Source code in <code>erdantic/examples/pydantic.py</code> <pre><code>class Quest(BaseModel):\n    \"\"\"A task to complete, with some monetary reward.\n\n    Attributes:\n        name (str): Name by which this quest is referred to\n        giver (QuestGiver): Person who offered the quest\n        reward_gold (int): Amount of gold to be rewarded for quest completion\n    \"\"\"\n\n    name: str\n    giver: QuestGiver\n    reward_gold: int = 100\n</code></pre>"},{"location":"api-reference/examples/pydantic/#erdantic.examples.pydantic.QuestGiver","title":"QuestGiver","text":"<p>             Bases: <code>BaseModel</code></p> <p>A person who offers a task that needs completing.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of this quest giver</p> <code>faction</code> <code>str</code> <p>Faction that this quest giver belongs to</p> <code>location</code> <code>str</code> <p>Location this quest giver can be found</p> Source code in <code>erdantic/examples/pydantic.py</code> <pre><code>class QuestGiver(BaseModel):\n    \"\"\"A person who offers a task that needs completing.\n\n    Attributes:\n        name (str): Name of this quest giver\n        faction (str): Faction that this quest giver belongs to\n        location (str): Location this quest giver can be found\n    \"\"\"\n\n    name: str\n    faction: Optional[str] = None\n    location: str = \"Adventurer's Guild\"\n</code></pre>"},{"location":"api-reference/examples/pydantic_v1/","title":"erdantic.examples.pydantic","text":"<p>Example data model classes using Pydantic.</p>"},{"location":"api-reference/examples/pydantic_v1/#erdantic.examples.pydantic.Adventurer","title":"Adventurer","text":"<p>             Bases: <code>BaseModel</code></p> <p>A person often late for dinner but with a tale or two to tell.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of this adventurer</p> <code>profession</code> <code>str</code> <p>Profession of this adventurer</p> <code>alignment</code> <code>Alignment</code> <p>Alignment of this adventurer</p> <code>level</code> <code>int</code> <p>Level of this adventurer</p> Source code in <code>erdantic/examples/pydantic.py</code> <pre><code>class Adventurer(BaseModel):\n    \"\"\"A person often late for dinner but with a tale or two to tell.\n\n    Attributes:\n        name (str): Name of this adventurer\n        profession (str): Profession of this adventurer\n        alignment (Alignment): Alignment of this adventurer\n        level (int): Level of this adventurer\n    \"\"\"\n\n    name: str\n    profession: str\n    alignment: Alignment\n    level: int = 1\n</code></pre>"},{"location":"api-reference/examples/pydantic_v1/#erdantic.examples.pydantic.Party","title":"Party","text":"<p>             Bases: <code>BaseModel</code></p> <p>A group of adventurers finding themselves doing and saying things altogether unexpected.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name that party is known by</p> <code>formed_datetime</code> <code>datetime</code> <p>Timestamp of when the party was formed</p> <code>members</code> <code>List[Adventurer]</code> <p>Adventurers that belong to this party</p> <code>active_quest</code> <code>Optional[Quest]</code> <p>Current quest that party is actively tackling</p> Source code in <code>erdantic/examples/pydantic.py</code> <pre><code>class Party(BaseModel):\n    \"\"\"A group of adventurers finding themselves doing and saying things altogether unexpected.\n\n    Attributes:\n        name (str): Name that party is known by\n        formed_datetime (datetime): Timestamp of when the party was formed\n        members (List[Adventurer]): Adventurers that belong to this party\n        active_quest (Optional[Quest]): Current quest that party is actively tackling\n    \"\"\"\n\n    name: str\n    formed_datetime: datetime\n    members: List[Adventurer] = []\n    active_quest: Optional[Quest] = None\n</code></pre>"},{"location":"api-reference/examples/pydantic_v1/#erdantic.examples.pydantic.Quest","title":"Quest","text":"<p>             Bases: <code>BaseModel</code></p> <p>A task to complete, with some monetary reward.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name by which this quest is referred to</p> <code>giver</code> <code>QuestGiver</code> <p>Person who offered the quest</p> <code>reward_gold</code> <code>int</code> <p>Amount of gold to be rewarded for quest completion</p> Source code in <code>erdantic/examples/pydantic.py</code> <pre><code>class Quest(BaseModel):\n    \"\"\"A task to complete, with some monetary reward.\n\n    Attributes:\n        name (str): Name by which this quest is referred to\n        giver (QuestGiver): Person who offered the quest\n        reward_gold (int): Amount of gold to be rewarded for quest completion\n    \"\"\"\n\n    name: str\n    giver: QuestGiver\n    reward_gold: int = 100\n</code></pre>"},{"location":"api-reference/examples/pydantic_v1/#erdantic.examples.pydantic.QuestGiver","title":"QuestGiver","text":"<p>             Bases: <code>BaseModel</code></p> <p>A person who offers a task that needs completing.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of this quest giver</p> <code>faction</code> <code>str</code> <p>Faction that this quest giver belongs to</p> <code>location</code> <code>str</code> <p>Location this quest giver can be found</p> Source code in <code>erdantic/examples/pydantic.py</code> <pre><code>class QuestGiver(BaseModel):\n    \"\"\"A person who offers a task that needs completing.\n\n    Attributes:\n        name (str): Name of this quest giver\n        faction (str): Faction that this quest giver belongs to\n        location (str): Location this quest giver can be found\n    \"\"\"\n\n    name: str\n    faction: Optional[str] = None\n    location: str = \"Adventurer's Guild\"\n</code></pre>"},{"location":"api-reference/plugins/","title":"erdantic.plugins","text":""},{"location":"api-reference/plugins/#erdantic.plugins.ModelFieldExtractor","title":"ModelFieldExtractor","text":"<p>             Bases: <code>Protocol[_ModelType_contra]</code></p> <p>Protocol class for a field extractor function for a plugin.</p> Source code in <code>erdantic/plugins/__init__.py</code> <pre><code>class ModelFieldExtractor(Protocol[_ModelType_contra]):\n    \"\"\"Protocol class for a field extractor function for a plugin.\"\"\"\n\n    def __call__(self, model: _ModelType_contra) -&gt; Sequence[\"FieldInfo\"]: ...\n</code></pre>"},{"location":"api-reference/plugins/#erdantic.plugins.ModelPredicate","title":"ModelPredicate","text":"<p>             Bases: <code>Protocol[_ModelType_co]</code></p> <p>Protocol class for a predicate function for a plugin.</p> Source code in <code>erdantic/plugins/__init__.py</code> <pre><code>class ModelPredicate(Protocol[_ModelType_co]):\n    \"\"\"Protocol class for a predicate function for a plugin.\"\"\"\n\n    def __call__(self, obj: Any) -&gt; TypeGuard[_ModelType_co]: ...\n</code></pre>"},{"location":"api-reference/plugins/#erdantic.plugins.get_field_extractor_fn","title":"get_field_extractor_fn","text":"<pre><code>get_field_extractor_fn(key: str) -&gt; ModelFieldExtractor\n</code></pre> <p>Get the field extractor function for a plugin by its key.</p> Source code in <code>erdantic/plugins/__init__.py</code> <pre><code>def get_field_extractor_fn(key: str) -&gt; ModelFieldExtractor:\n    \"\"\"Get the field extractor function for a plugin by its key.\"\"\"\n    try:\n        return _dict[key][1]\n    except KeyError:\n        raise PluginNotFoundError(key=key)\n</code></pre>"},{"location":"api-reference/plugins/#erdantic.plugins.get_predicate_fn","title":"get_predicate_fn","text":"<pre><code>get_predicate_fn(key: str) -&gt; ModelPredicate\n</code></pre> <p>Get the predicate function for a plugin by its key.</p> Source code in <code>erdantic/plugins/__init__.py</code> <pre><code>def get_predicate_fn(key: str) -&gt; ModelPredicate:\n    \"\"\"Get the predicate function for a plugin by its key.\"\"\"\n    try:\n        return _dict[key][0]\n    except KeyError:\n        raise PluginNotFoundError(key=key)\n</code></pre>"},{"location":"api-reference/plugins/#erdantic.plugins.identify_field_extractor_fn","title":"identify_field_extractor_fn","text":"<pre><code>identify_field_extractor_fn(\n    tp: type,\n) -&gt; Optional[ModelFieldExtractor]\n</code></pre> <p>Identify the field extractor function for a model type.</p> <p>Parameters:</p> Name Type Description Default <code>tp</code> <code>type</code> <p>A type annotation.</p> required <p>Returns:</p> Type Description <code>ModelFieldExtractor | None</code> <p>The field extractor function for a known model type, or None if the model type is not recognized by any registered plugins.</p> Source code in <code>erdantic/plugins/__init__.py</code> <pre><code>def identify_field_extractor_fn(tp: type) -&gt; Optional[ModelFieldExtractor]:\n    \"\"\"Identify the field extractor function for a model type.\n\n    Args:\n        tp (type): A type annotation.\n\n    Returns:\n        ModelFieldExtractor | None: The field extractor function for a known model type, or None if\n            the model type is not recognized by any registered plugins.\n    \"\"\"\n    for key, (predicate_fn, get_fields_fn) in _dict.items():\n        if predicate_fn(tp):\n            logger.debug(\"Identified '%s' as a '%s' model.\", typenames(tp), key)\n            return get_fields_fn\n    logger.debug(\"'%s' is not a known model type.\", typenames(tp))\n    return None\n</code></pre>"},{"location":"api-reference/plugins/#erdantic.plugins.list_plugins","title":"list_plugins","text":"<pre><code>list_plugins() -&gt; List[str]\n</code></pre> <p>List the keys of all registered plugins.</p> Source code in <code>erdantic/plugins/__init__.py</code> <pre><code>def list_plugins() -&gt; List[str]:\n    \"\"\"List the keys of all registered plugins.\"\"\"\n    return list(_dict.keys())\n</code></pre>"},{"location":"api-reference/plugins/#erdantic.plugins.register_plugin","title":"register_plugin","text":"<pre><code>register_plugin(\n    key: str,\n    predicate_fn: ModelPredicate[_ModelType],\n    get_fields_fn: ModelFieldExtractor[_ModelType],\n)\n</code></pre> <p>Register a plugin for a specific model class type.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>An identifier for this plugin.</p> required <code>predicate_fn</code> <code>ModelPredicate</code> <p>A predicate function to determine if an object is a class of the model that is supported by this plugin.</p> required <code>get_fields_fn</code> <code>ModelFieldExtractor</code> <p>A function to extract fields from a model class that is supported by this plugin.</p> required Source code in <code>erdantic/plugins/__init__.py</code> <pre><code>def register_plugin(\n    key: str,\n    predicate_fn: ModelPredicate[_ModelType],\n    get_fields_fn: ModelFieldExtractor[_ModelType],\n):\n    \"\"\"Register a plugin for a specific model class type.\n\n    Args:\n        key (str): An identifier for this plugin.\n        predicate_fn (ModelPredicate): A predicate function to determine if an object is a class\n            of the model that is supported by this plugin.\n        get_fields_fn (ModelFieldExtractor): A function to extract fields from a model class that\n            is supported by this plugin.\n    \"\"\"\n    logger.debug(\"Registering plugin '%s'\", key)\n    if key in _dict:\n        logger.warning(\"Overwriting existing implementation for key '%s'\", key)\n    _dict[key] = (predicate_fn, get_fields_fn)\n</code></pre>"},{"location":"api-reference/plugins/attrs/","title":"erdantic.plugins.attrs","text":""},{"location":"api-reference/plugins/attrs/#erdantic.plugins.attrs.get_fields_from_attrs_class","title":"get_fields_from_attrs_class","text":"<pre><code>get_fields_from_attrs_class(\n    model: AttrsClassType,\n) -&gt; List[FieldInfo]\n</code></pre> <p>Given an attrs class, return a list of FieldInfo instances for each field in the class.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>AttrsClassType</code> <p>The attrs class to get fields from.</p> required <p>Returns:</p> Type Description <code>List[FieldInfo]</code> <p>List of FieldInfo instances for each field in the class</p> Source code in <code>erdantic/plugins/attrs.py</code> <pre><code>def get_fields_from_attrs_class(model: AttrsClassType) -&gt; List[FieldInfo]:\n    \"\"\"Given an attrs class, return a list of FieldInfo instances for each field in the class.\n\n    Args:\n        model (AttrsClassType): The attrs class to get fields from.\n\n    Returns:\n        List[FieldInfo]: List of FieldInfo instances for each field in the class\n    \"\"\"\n    try:\n        # Try to automatically resolve forward references\n        attrs.resolve_types(model)\n    except NameError as e:\n        model_full_name = FullyQualifiedName.from_object(model)\n        forward_ref = getattr(\n            e,\n            \"name\",\n            re.search(r\"(?&lt;=')(?:[^'])*(?=')\", str(e)).group(0),  # type: ignore [union-attr]\n        )\n        msg = (\n            f\"Failed to resolve forward reference '{forward_ref}' in the type annotations for \"\n            f\"attrs class {model_full_name}. \"\n            \"You should use attrs.resolve_types with locals() where you define the class.\"\n        )\n        raise UnresolvableForwardRefError(\n            msg, name=forward_ref, model_full_name=model_full_name\n        ) from e\n    return [\n        FieldInfo.from_raw_type(\n            model_full_name=FullyQualifiedName.from_object(model),\n            name=attrib.name,\n            raw_type=attrib.type,\n        )\n        for attrib in attrs.fields(model)\n    ]\n</code></pre>"},{"location":"api-reference/plugins/attrs/#erdantic.plugins.attrs.is_attrs_class","title":"is_attrs_class","text":"<pre><code>is_attrs_class(obj: Any) -&gt; TypeGuard[AttrsClassType]\n</code></pre> <p>Predicate function to determine if an object is an attrs class (not an instance).</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the object is an attrs class, False otherwise.</p> Source code in <code>erdantic/plugins/attrs.py</code> <pre><code>def is_attrs_class(obj: Any) -&gt; TypeGuard[AttrsClassType]:\n    \"\"\"Predicate function to determine if an object is an attrs class (not an instance).\n\n    Args:\n        obj (Any): The object to check.\n\n    Returns:\n        bool: True if the object is an attrs class, False otherwise.\n    \"\"\"\n    return isinstance(obj, type) and attrs.has(obj)\n</code></pre>"},{"location":"api-reference/plugins/dataclasses/","title":"erdantic.plugins.dataclasses","text":""},{"location":"api-reference/plugins/dataclasses/#erdantic.plugins.dataclasses.get_fields_from_dataclass","title":"get_fields_from_dataclass","text":"<pre><code>get_fields_from_dataclass(\n    model: DataclassType,\n) -&gt; List[FieldInfo]\n</code></pre> <p>Given a dataclass, return a list of FieldInfo instances for each field in the class.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>DataclassType</code> <p>The dataclass to get fields from.</p> required <p>Returns:</p> Type Description <code>List[FieldInfo]</code> <p>List of FieldInfo instances for each field in the class</p> Source code in <code>erdantic/plugins/dataclasses.py</code> <pre><code>def get_fields_from_dataclass(model: DataclassType) -&gt; List[FieldInfo]:\n    \"\"\"Given a dataclass, return a list of FieldInfo instances for each field in the class.\n\n    Args:\n        model (DataclassType): The dataclass to get fields from.\n\n    Returns:\n        List[FieldInfo]: List of FieldInfo instances for each field in the class\n    \"\"\"\n    try:\n        # Try to automatically resolve forward references\n        resolve_types_on_dataclass(model)\n    except NameError as e:\n        model_full_name = FullyQualifiedName.from_object(model)\n        forward_ref = getattr(\n            e,\n            \"name\",\n            re.search(r\"(?&lt;=')(?:[^'])*(?=')\", str(e)).group(0),  # type: ignore [union-attr]\n        )\n        msg = (\n            f\"Failed to resolve forward reference '{forward_ref}' in the type annotations for \"\n            f\"dataclass {model_full_name}. \"\n            \"You should use erdantic.plugins.dataclasses.resolve_types_on_dataclass with locals() \"\n            \"where you define the class.\"\n        )\n        raise UnresolvableForwardRefError(\n            msg, name=forward_ref, model_full_name=model_full_name\n        ) from e\n    return [\n        FieldInfo.from_raw_type(\n            model_full_name=FullyQualifiedName.from_object(model),\n            name=f.name,\n            raw_type=f.type,\n        )\n        for f in dataclasses.fields(model)\n    ]\n</code></pre>"},{"location":"api-reference/plugins/dataclasses/#erdantic.plugins.dataclasses.is_dataclass_class","title":"is_dataclass_class","text":"<pre><code>is_dataclass_class(obj: Any) -&gt; TypeGuard[DataclassType]\n</code></pre> <p>Predicate function to determine if an object is a dataclass (not an instance).</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the object is a dataclass, False otherwise.</p> Source code in <code>erdantic/plugins/dataclasses.py</code> <pre><code>def is_dataclass_class(obj: Any) -&gt; TypeGuard[DataclassType]:\n    \"\"\"Predicate function to determine if an object is a dataclass (not an instance).\n\n    Args:\n        obj (Any): The object to check.\n\n    Returns:\n        bool: True if the object is a dataclass, False otherwise.\n    \"\"\"\n    return isinstance(obj, type) and dataclasses.is_dataclass(obj)\n</code></pre>"},{"location":"api-reference/plugins/dataclasses/#erdantic.plugins.dataclasses.resolve_types_on_dataclass","title":"resolve_types_on_dataclass","text":"<pre><code>resolve_types_on_dataclass(\n    cls: DataclassType,\n    globalns=None,\n    localns=None,\n    include_extras=True,\n) -&gt; DataclassType\n</code></pre> <p>Resolve forward references in type annotations on a dataclass. This will modify the fields metadata on the class to replace forward references with the actual types.</p> <p>Parameters:</p> Name Type Description Default <code>cls</code> <code>DataclassType</code> <p>The dataclass to resolve forward references on.</p> required <code>globalns</code> <code>Dict[str, Any] | None</code> <p>A global namespace to evaluate forward references against. Defaults to None.</p> <code>None</code> <code>localns</code> <code>Dict[str, Any] | None</code> <p>A local namespace to evaluate forward references against. Defaults to None.</p> <code>None</code> <code>include_extras</code> <code>bool</code> <p>Whether to keep extra metadata from <code>typing.Annotated</code>. Defaults to True.</p> <code>True</code> Source code in <code>erdantic/plugins/dataclasses.py</code> <pre><code>def resolve_types_on_dataclass(\n    cls: DataclassType, globalns=None, localns=None, include_extras=True\n) -&gt; DataclassType:\n    \"\"\"Resolve forward references in type annotations on a dataclass. This will modify the fields\n    metadata on the class to replace forward references with the actual types.\n\n    Args:\n        cls (DataclassType): The dataclass to resolve forward references on.\n        globalns (Dict[str, Any] | None, optional): A global namespace to evaluate forward\n            references against. Defaults to None.\n        localns (Dict[str, Any] | None, optional): A local namespace to evaluate forward\n            references against. Defaults to None.\n        include_extras (bool, optional): Whether to keep extra metadata from `typing.Annotated`.\n            Defaults to True.\n    \"\"\"\n    # Cache whether we have already run this on a cls\n    # Inspired by attrs.resolve_types\n    if getattr(cls, \"__erdantic_dataclass_types_resolved__\", None) != cls:\n        hints = get_type_hints(\n            cls, globalns=globalns, localns=localns, include_extras=include_extras\n        )\n        for field in dataclasses.fields(cls):\n            field.type = hints[field.name]\n        # Use reference to cls as indicator in case of subclasses\n        setattr(cls, \"__erdantic_dataclass_types_resolved__\", cls)\n    return cls\n</code></pre>"},{"location":"api-reference/plugins/pydantic/","title":"erdantic.plugins.pydantic","text":""},{"location":"api-reference/plugins/pydantic/#erdantic.plugins.pydantic.get_fields_from_pydantic_model","title":"get_fields_from_pydantic_model","text":"<pre><code>get_fields_from_pydantic_model(\n    model: PydanticModel,\n) -&gt; List[FieldInfo]\n</code></pre> <p>Given a Pydantic model, return a list of FieldInfo instances for each field in the model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>PydanticModel</code> <p>The Pydantic model to get fields from.</p> required <p>Returns:</p> Type Description <code>List[FieldInfo]</code> <p>List of FieldInfo instances for each field in the model</p> Source code in <code>erdantic/plugins/pydantic.py</code> <pre><code>def get_fields_from_pydantic_model(model: PydanticModel) -&gt; List[FieldInfo]:\n    \"\"\"Given a Pydantic model, return a list of FieldInfo instances for each field in the model.\n\n    Args:\n        model (PydanticModel): The Pydantic model to get fields from.\n\n    Returns:\n        List[FieldInfo]: List of FieldInfo instances for each field in the model\n    \"\"\"\n    try:\n        # Rebuild model schema to resolve forward references\n        model.model_rebuild()\n    except pydantic.errors.PydanticUndefinedAnnotation as e:\n        model_full_name = FullyQualifiedName.from_object(model)\n        forward_ref = e.name\n        msg = (\n            f\"Failed to resolve forward reference '{forward_ref}' in the type annotations for \"\n            f\"Pydantic model {model_full_name}. \"\n            \"You should use the model's model_rebuild() method to manually resolve it.\"\n        )\n        raise UnresolvableForwardRefError(\n            msg, name=forward_ref, model_full_name=model_full_name\n        ) from e\n    return [\n        FieldInfo.from_raw_type(\n            model_full_name=FullyQualifiedName.from_object(model),\n            name=name,\n            # typing special forms currently get typed as object\n            # https://github.com/python/mypy/issues/9773\n            raw_type=pydantic_field_info.annotation or Any,  # type: ignore\n        )\n        for name, pydantic_field_info in model.model_fields.items()\n    ]\n</code></pre>"},{"location":"api-reference/plugins/pydantic/#erdantic.plugins.pydantic.get_fields_from_pydantic_v1_model","title":"get_fields_from_pydantic_v1_model","text":"<pre><code>get_fields_from_pydantic_v1_model(\n    model: PydanticV1Model,\n) -&gt; List[FieldInfo]\n</code></pre> <p>Given a Pydantic V1 model, return a list of FieldInfo instances for each field in the model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>PydanticV1Model</code> <p>The Pydantic V1 model to get fields from.</p> required <p>Returns:</p> Type Description <code>List[FieldInfo]</code> <p>List of FieldInfo instances for each field in the model</p> Source code in <code>erdantic/plugins/pydantic.py</code> <pre><code>def get_fields_from_pydantic_v1_model(model: PydanticV1Model) -&gt; List[FieldInfo]:\n    \"\"\"Given a Pydantic V1 model, return a list of FieldInfo instances for each field in the model.\n\n    Args:\n        model (PydanticV1Model): The Pydantic V1 model to get fields from.\n\n    Returns:\n        List[FieldInfo]: List of FieldInfo instances for each field in the model\n    \"\"\"\n    try:\n        model.update_forward_refs()\n    except NameError as e:\n        model_full_name = FullyQualifiedName.from_object(model)\n        # NameError attribute 'name' was added in Python 3.10\n        forward_ref = getattr(\n            e,\n            \"name\",\n            re.search(r\"(?&lt;=')(?:[^'])*(?=')\", str(e)).group(0),  # type: ignore [union-attr]\n        )\n        msg = (\n            f\"Failed to resolve forward reference '{forward_ref}' in the type annotations for \"\n            f\"Pydantic V1 model {model_full_name}. \"\n            \"You should call the method update_forward_refs(**locals()) on the model in \"\n            \"the scope where it has been defined to manually resolve it.\"\n        )\n        raise UnresolvableForwardRefError(\n            msg, name=forward_ref, model_full_name=model_full_name\n        ) from e\n\n    return [\n        FieldInfo.from_raw_type(\n            model_full_name=FullyQualifiedName.from_object(model),\n            name=name,\n            raw_type=get_type_annotation_from_pydantic_v1_field(field),\n        )\n        for name, field in model.__fields__.items()\n    ]\n</code></pre>"},{"location":"api-reference/plugins/pydantic/#erdantic.plugins.pydantic.get_type_annotation_from_pydantic_v1_field","title":"get_type_annotation_from_pydantic_v1_field","text":"<pre><code>get_type_annotation_from_pydantic_v1_field(\n    field_info: ModelField,\n) -&gt; type\n</code></pre> <p>Utility function to get the type annotation from a Pydantic V1 field info object.</p> Source code in <code>erdantic/plugins/pydantic.py</code> <pre><code>def get_type_annotation_from_pydantic_v1_field(field_info: pydantic.v1.fields.ModelField) -&gt; type:\n    \"\"\"Utility function to get the type annotation from a Pydantic V1 field info object.\"\"\"\n    tp = field_info.outer_type_\n    if field_info.allow_none:\n        return Optional[tp]  # type: ignore\n    return tp\n</code></pre>"},{"location":"api-reference/plugins/pydantic/#erdantic.plugins.pydantic.is_pydantic_model","title":"is_pydantic_model","text":"<pre><code>is_pydantic_model(obj: Any) -&gt; TypeGuard[PydanticModel]\n</code></pre> <p>Predicate function to determine if an object is a Pydantic model (not an instance).</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the object is a Pydantic model, False otherwise.</p> Source code in <code>erdantic/plugins/pydantic.py</code> <pre><code>def is_pydantic_model(obj: Any) -&gt; TypeGuard[PydanticModel]:\n    \"\"\"Predicate function to determine if an object is a Pydantic model (not an instance).\n\n    Args:\n        obj (Any): The object to check.\n\n    Returns:\n        bool: True if the object is a Pydantic model, False otherwise.\n    \"\"\"\n    return isinstance(obj, type) and issubclass(obj, pydantic.BaseModel)\n</code></pre>"},{"location":"api-reference/plugins/pydantic/#erdantic.plugins.pydantic.is_pydantic_v1_model","title":"is_pydantic_v1_model","text":"<pre><code>is_pydantic_v1_model(obj) -&gt; TypeGuard[PydanticV1Model]\n</code></pre> <p>Predicate function to determine if an object is a Pydantic V1 model (not an instance). This is for models that use the legacy <code>pydantic.v1</code> namespace.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the object is a Pydantic V1 model, False otherwise.</p> Source code in <code>erdantic/plugins/pydantic.py</code> <pre><code>def is_pydantic_v1_model(obj) -&gt; TypeGuard[PydanticV1Model]:\n    \"\"\"Predicate function to determine if an object is a Pydantic V1 model (not an instance). This\n    is for models that use the legacy `pydantic.v1` namespace.\n\n    Args:\n        obj (Any): The object to check.\n\n    Returns:\n        bool: True if the object is a Pydantic V1 model, False otherwise.\n    \"\"\"\n    return isinstance(obj, type) and issubclass(obj, pydantic.v1.BaseModel)\n</code></pre>"},{"location":"examples/attrs/","title":"Usage Example: attrs","text":"In\u00a0[1]: Copied! <pre>import inspect\nimport rich.syntax\n\nimport erdantic.examples.attrs\n\n\nrich.syntax.Syntax(\n    inspect.getsource(erdantic.examples.attrs), \n    \"python\",\n    theme=\"default\",\n    line_numbers=True\n)\n</pre> import inspect import rich.syntax  import erdantic.examples.attrs   rich.syntax.Syntax(     inspect.getsource(erdantic.examples.attrs),      \"python\",     theme=\"default\",     line_numbers=True ) Out[1]: <pre>   1 \"\"\"Example data model classes using standard library's                                                        \n   2 [`dataclasses`](https://docs.python.org/3/library/dataclasses.html) module.\"\"\"                                \n   3                                                                                                               \n   4 from datetime import datetime                                                                                 \n   5 from enum import Enum                                                                                         \n   6 from typing import List, Optional                                                                             \n   7                                                                                                               \n   8 from attrs import define, field                                                                               \n   9                                                                                                               \n  10                                                                                                               \n  11 class Alignment(str, Enum):                                                                                   \n  12     LAWFUL_GOOD = \"lawful_good\"                                                                               \n  13     NEUTRAL_GOOD = \"neutral_good\"                                                                             \n  14     CHAOTIC_GOOD = \"chaotic_good\"                                                                             \n  15     LAWFUL_NEUTRAL = \"lawful_neutral\"                                                                         \n  16     TRUE_NEUTRAL = \"true_neutral\"                                                                             \n  17     CHAOTIC_NEUTRAL = \"chaotic_neutral\"                                                                       \n  18     LAWFUL_EVIL = \"lawful_evil\"                                                                               \n  19     NEUTRAL_EVIL = \"neutral_evil\"                                                                             \n  20     CHAOTIC_EVIL = \"chaotic_evil\"                                                                             \n  21                                                                                                               \n  22                                                                                                               \n  23 @define                                                                                                       \n  24 class Adventurer:                                                                                             \n  25     \"\"\"A person often late for dinner but with a tale or two to tell.                                         \n  26                                                                                                               \n  27     Attributes:                                                                                               \n  28         name (str): Name of this adventurer                                                                   \n  29         profession (str): Profession of this adventurer                                                       \n  30         level (int): Level of this adventurer                                                                 \n  31         alignment (Alignment): Alignment of this adventurer                                                   \n  32     \"\"\"                                                                                                       \n  33                                                                                                               \n  34     name: str                                                                                                 \n  35     profession: str                                                                                           \n  36     alignment: Alignment                                                                                      \n  37     level: int = 1                                                                                            \n  38                                                                                                               \n  39                                                                                                               \n  40 @define                                                                                                       \n  41 class QuestGiver:                                                                                             \n  42     \"\"\"A person who offers a task that needs completing.                                                      \n  43                                                                                                               \n  44     Attributes:                                                                                               \n  45         name (str): Name of this quest giver                                                                  \n  46         faction (str): Faction that this quest giver belongs to                                               \n  47         location (str): Location this quest giver can be found                                                \n  48     \"\"\"                                                                                                       \n  49                                                                                                               \n  50     name: str                                                                                                 \n  51     faction: Optional[str] = None                                                                             \n  52     location: str = \"Adventurer's Guild\"                                                                      \n  53                                                                                                               \n  54                                                                                                               \n  55 @define                                                                                                       \n  56 class Quest:                                                                                                  \n  57     \"\"\"A task to complete, with some monetary reward.                                                         \n  58                                                                                                               \n  59     Attributes:                                                                                               \n  60         name (str): Name by which this quest is referred to                                                   \n  61         giver (QuestGiver): Person who offered the quest                                                      \n  62         reward_gold (int): Amount of gold to be rewarded for quest completion                                 \n  63     \"\"\"                                                                                                       \n  64                                                                                                               \n  65     name: str                                                                                                 \n  66     giver: QuestGiver                                                                                         \n  67     reward_gold: int = 100                                                                                    \n  68                                                                                                               \n  69                                                                                                               \n  70 @define                                                                                                       \n  71 class Party:                                                                                                  \n  72     \"\"\"A group of adventurers finding themselves doing and saying things altogether unexpected.               \n  73                                                                                                               \n  74     Attributes:                                                                                               \n  75         name (str): Name that party is known by                                                               \n  76         formed_datetime (datetime): Timestamp of when the party was formed                                    \n  77         members (List[Adventurer]): Adventurers that belong to this party                                     \n  78         active_quest (Optional[Quest]): Current quest that party is actively tackling                         \n  79     \"\"\"                                                                                                       \n  80                                                                                                               \n  81     name: str                                                                                                 \n  82     formed_datetime: datetime                                                                                 \n  83     members: List[Adventurer] = field(factory=list)                                                           \n  84     active_quest: Optional[Quest] = None                                                                      \n  85                                                                                                               \n</pre> In\u00a0[2]: Copied! <pre>!erdantic erdantic.examples.attrs.Party -o diagram.png\n</pre> !erdantic erdantic.examples.attrs.Party -o diagram.png <pre>2024-03-31 00:39:53,319 | erdantic.core | INFO | Adding model 'erdantic.examples.attrs.Party' to diagram...\r\n2024-03-31 00:39:53,321 | erdantic.core | INFO | Rendering diagram to diagram.png\r\n</pre> <pre>2024-03-31 00:39:54,367 | erdantic.cli | INFO | Rendered diagram to diagram.png\r\n</pre> <p>The format rendered is inferred from the file extension.</p> In\u00a0[3]: Copied! <pre>import erdantic as erd\nfrom erdantic.examples.attrs import Party\n\n\ndiagram = erd.create(Party)\ndiagram\n</pre> import erdantic as erd from erdantic.examples.attrs import Party   diagram = erd.create(Party) diagram <pre>EntityRelationshipDiagram(\n    models={\n        'erdantic.examples.attrs.Adventurer': ModelInfo(...),\n        'erdantic.examples.attrs.Party': ModelInfo(...),\n        'erdantic.examples.attrs.Quest': ModelInfo(...),\n        'erdantic.examples.attrs.QuestGiver': ModelInfo(...)\n    },\n    edges={\n        'erdantic.examples.attrs.Party-active_quest-erdantic.examples.attrs.Quest': Edge(...),\n        'erdantic.examples.attrs.Party-members-erdantic.examples.attrs.Adventurer': Edge(...),\n        'erdantic.examples.attrs.Quest-giver-erdantic.examples.attrs.QuestGiver': Edge(...)\n    }\n)\n</pre> Out[3]: <p>The <code>models</code> attribute gives you access to a dictionary of <code>ModelInfo</code> objects that contain the data for each model in the diagram. All of erdantic's data objects are Pydantic models.</p> <p>Tip</p> <p>     If you have the rich library installed, the IPython/Jupyter representation of erdantic's data objects will be nicely colored. </p> In\u00a0[4]: Copied! <pre>list(diagram.models.keys())\n</pre> list(diagram.models.keys()) Out[4]: <pre>['erdantic.examples.attrs.Adventurer',\n 'erdantic.examples.attrs.Party',\n 'erdantic.examples.attrs.Quest',\n 'erdantic.examples.attrs.QuestGiver']</pre> In\u00a0[5]: Copied! <pre>diagram.models['erdantic.examples.attrs.Party']\n</pre> diagram.models['erdantic.examples.attrs.Party'] <pre>ModelInfo(\n    full_name=FullyQualifiedName(module='erdantic.examples.attrs', qual_name='Party'),\n    name='Party',\n    fields={\n        'name': FieldInfo(\n            model_full_name=FullyQualifiedName(module='erdantic.examples.attrs', qual_name='Party'),\n            name='name',\n            type_name='str'\n        ),\n        'formed_datetime': FieldInfo(\n            model_full_name=FullyQualifiedName(module='erdantic.examples.attrs', qual_name='Party'),\n            name='formed_datetime',\n            type_name='datetime'\n        ),\n        'members': FieldInfo(\n            model_full_name=FullyQualifiedName(module='erdantic.examples.attrs', qual_name='Party'),\n            name='members',\n            type_name='List[Adventurer]'\n        ),\n        'active_quest': FieldInfo(\n            model_full_name=FullyQualifiedName(module='erdantic.examples.attrs', qual_name='Party'),\n            name='active_quest',\n            type_name='Optional[Quest]'\n        )\n    },\n    description='erdantic.examples.attrs.Party\\n\\nA group of adventurers finding themselves doing and saying things\naltogether unexpected.\\n\\nAttributes:\\n    name (str): Name that party is known by\\n    formed_datetime (datetime):\nTimestamp of when the party was formed\\n    members (List[Adventurer]): Adventurers that belong to this party\\n    \nactive_quest (Optional[Quest]): Current quest that party is actively tackling\\n'\n)\n</pre> Out[5]: <pre></pre> <p>And the <code>edges</code> attribute gives you access to a dictionary of <code>Edge</code> objects that contain the data for each relationship between the models.</p> In\u00a0[6]: Copied! <pre>list(diagram.edges.keys())\n</pre> list(diagram.edges.keys()) Out[6]: <pre>['erdantic.examples.attrs.Party-active_quest-erdantic.examples.attrs.Quest',\n 'erdantic.examples.attrs.Party-members-erdantic.examples.attrs.Adventurer',\n 'erdantic.examples.attrs.Quest-giver-erdantic.examples.attrs.QuestGiver']</pre> In\u00a0[7]: Copied! <pre>diagram.edges[\"erdantic.examples.attrs.Party-members-erdantic.examples.attrs.Adventurer\"]\n</pre> diagram.edges[\"erdantic.examples.attrs.Party-members-erdantic.examples.attrs.Adventurer\"] <pre>Edge(\n    source_model_full_name=FullyQualifiedName(module='erdantic.examples.attrs', qual_name='Party'),\n    source_field_name='members',\n    target_model_full_name=FullyQualifiedName(module='erdantic.examples.attrs', qual_name='Adventurer'),\n    target_cardinality=&lt;Cardinality.MANY: 'many'&gt;,\n    target_modality=&lt;Modality.UNSPECIFIED: 'unspecified'&gt;,\n    source_cardinality=&lt;Cardinality.UNSPECIFIED: 'unspecified'&gt;,\n    source_modality=&lt;Modality.UNSPECIFIED: 'unspecified'&gt;\n)\n</pre> Out[7]: <pre></pre> <p>You can use the <code>draw</code> method to render the diagram to disk.</p> In\u00a0[8]: Copied! <pre>diagram.draw(\"diagram.svg\")\n\n# Equivalently, use erd.draw directly from Party\n# erd.draw(Party, out=\"diagram.svg\")\n</pre> diagram.draw(\"diagram.svg\")  # Equivalently, use erd.draw directly from Party # erd.draw(Party, out=\"diagram.svg\") <p>erdantic uses Graphviz, a well-established open-source C library, to create the diagram. Graphviz uses the DOT language for describing graphs. You use the <code>to_dot</code> method to get the DOT representation as a string.</p> In\u00a0[9]: Copied! <pre>print(diagram.to_dot())\n\n# Equivalently, use erd.to_dot directly from Party\nassert diagram.to_dot() == erd.to_dot(Party)\n</pre> print(diagram.to_dot())  # Equivalently, use erd.to_dot directly from Party assert diagram.to_dot() == erd.to_dot(Party) <pre>digraph \"Entity Relationship Diagram created by erdantic\" {\n\tgraph [fontcolor=gray66,\n\t\tfontname=\"Times New Roman,Times,Liberation Serif,serif\",\n\t\tfontsize=9,\n\t\tlabel=\"Created by erdantic v1.0.0rc1 &lt;https://github.com/drivendataorg/erdantic&gt;\",\n\t\tnodesep=0.5,\n\t\trankdir=LR,\n\t\tranksep=1.5\n\t];\n\tnode [fontname=\"Times New Roman,Times,Liberation Serif,serif\",\n\t\tfontsize=14,\n\t\tlabel=\"\\N\",\n\t\tshape=plain\n\t];\n\tedge [dir=both];\n\t\"erdantic.examples.attrs.Adventurer\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;Adventurer&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;profession&lt;/td&gt;&lt;td port=\"profession\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;alignment&lt;/td&gt;&lt;td port=\"alignment\"&gt;Alignment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;level&lt;/td&gt;&lt;td port=\"level\"&gt;int&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.attrs.Adventurer&amp;#xA;&amp;#xA;A person often late for dinner but with a tale or two to tell.&amp;#xA;&amp;#xA;Attributes:&amp;#\\\nxA;    name (str): Name of this adventurer&amp;#xA;    profession (str): Profession of this adventurer&amp;#xA;    level (int): Level of \\\nthis adventurer&amp;#xA;    alignment (Alignment): Alignment of this adventurer&amp;#xA;\"];\n\t\"erdantic.examples.attrs.Party\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;Party&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;formed_datetime&lt;/td&gt;&lt;td port=\"formed_datetime\"&gt;datetime&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;members&lt;/td&gt;&lt;td port=\"members\"&gt;List[Adventurer]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;active_quest&lt;/td&gt;&lt;td port=\"active_quest\"&gt;Optional[Quest]&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.attrs.Party&amp;#xA;&amp;#xA;A group of adventurers finding themselves doing and saying things altogether unexpected.&amp;#\\\nxA;&amp;#xA;Attributes:&amp;#xA;    name (str): Name that party is known by&amp;#xA;    formed_datetime (datetime): Timestamp of when the party \\\nwas formed&amp;#xA;    members (List[Adventurer]): Adventurers that belong to this party&amp;#xA;    active_quest (Optional[Quest]): Current \\\nquest that party is actively tackling&amp;#xA;\"];\n\t\"erdantic.examples.attrs.Party\":members:e -&gt; \"erdantic.examples.attrs.Adventurer\":_root:w\t[arrowhead=crownone,\n\t\tarrowtail=nonenone];\n\t\"erdantic.examples.attrs.Quest\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;Quest&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;giver&lt;/td&gt;&lt;td port=\"giver\"&gt;QuestGiver&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;reward_gold&lt;/td&gt;&lt;td port=\"reward_gold\"&gt;int&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.attrs.Quest&amp;#xA;&amp;#xA;A task to complete, with some monetary reward.&amp;#xA;&amp;#xA;Attributes:&amp;#xA;    name (str): Name \\\nby which this quest is referred to&amp;#xA;    giver (QuestGiver): Person who offered the quest&amp;#xA;    reward_gold (int): Amount of \\\ngold to be rewarded for quest completion&amp;#xA;\"];\n\t\"erdantic.examples.attrs.Party\":active_quest:e -&gt; \"erdantic.examples.attrs.Quest\":_root:w\t[arrowhead=noneteeodot,\n\t\tarrowtail=nonenone];\n\t\"erdantic.examples.attrs.QuestGiver\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;QuestGiver&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;faction&lt;/td&gt;&lt;td port=\"faction\"&gt;Optional[str]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;location&lt;/td&gt;&lt;td port=\"location\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.attrs.QuestGiver&amp;#xA;&amp;#xA;A person who offers a task that needs completing.&amp;#xA;&amp;#xA;Attributes:&amp;#xA;    name (\\\nstr): Name of this quest giver&amp;#xA;    faction (str): Faction that this quest giver belongs to&amp;#xA;    location (str): Location \\\nthis quest giver can be found&amp;#xA;\"];\n\t\"erdantic.examples.attrs.Quest\":giver:e -&gt; \"erdantic.examples.attrs.QuestGiver\":_root:w\t[arrowhead=noneteetee,\n\t\tarrowtail=nonenone];\n}\n\n</pre> <p>When using the Python library, pass your terminal node in a list to the <code>terminal_models</code> keyword argument. Below is the Python code for creating diagrams equivalent to the above shell commands.</p> In\u00a0[10]: Copied! <pre>from erdantic.examples.attrs import Quest\n\ndiagram1 = erd.create(Party, terminal_models=[Quest])\ndiagram1\n</pre> from erdantic.examples.attrs import Quest  diagram1 = erd.create(Party, terminal_models=[Quest]) diagram1 <pre>EntityRelationshipDiagram(\n    models={\n        'erdantic.examples.attrs.Adventurer': ModelInfo(...),\n        'erdantic.examples.attrs.Party': ModelInfo(...),\n        'erdantic.examples.attrs.Quest': ModelInfo(...)\n    },\n    edges={\n        'erdantic.examples.attrs.Party-active_quest-erdantic.examples.attrs.Quest': Edge(...),\n        'erdantic.examples.attrs.Party-members-erdantic.examples.attrs.Adventurer': Edge(...)\n    }\n)\n</pre> Out[10]: In\u00a0[11]: Copied! <pre>diagram2 = erd.create(Quest)\ndiagram2\n</pre> diagram2 = erd.create(Quest) diagram2 <pre>EntityRelationshipDiagram(\n    models={\n        'erdantic.examples.attrs.Quest': ModelInfo(...),\n        'erdantic.examples.attrs.QuestGiver': ModelInfo(...)\n    },\n    edges={'erdantic.examples.attrs.Quest-giver-erdantic.examples.attrs.QuestGiver': Edge(...)}\n)\n</pre> Out[11]:"},{"location":"examples/attrs/#usage-example-attrs","title":"Usage Example: attrs\u00b6","text":"<p>This notebook shows an example of using erdantic with classes created with the attrs package.</p> <p>Let's take a look at the attrs classes (from here on in referred to as \"models\") from the <code>erdantic.examples.attrs</code> module. Here's their source code for clarity.</p>"},{"location":"examples/attrs/#using-the-cli","title":"Using the CLI\u00b6","text":"<p>The fastest way to rendering a diagram is to use the command-line interface. Below we use IPython's <code>!</code> to run a command in the system shell. We pass the full dotted path to the root class of our composition hierarchy, along with an output file path. erdantic will walk the composition graph to find all child classes.</p>"},{"location":"examples/attrs/#using-the-python-library","title":"Using the Python library\u00b6","text":"<p>You can also use the erdantic Python library, which lets you inspect the diagram object. The diagram object contains all of the data that erdantic extracted about the model you provide, as well as any related models. As demonstrated below, the diagram object automatically pretty-prints in IPython or Jupyter notebooks and even automatically renders in Jupyter notebooks.</p>"},{"location":"examples/attrs/#inspecting-the-data","title":"Inspecting the data\u00b6","text":""},{"location":"examples/attrs/#rendering-the-diagram-to-an-image-file","title":"Rendering the diagram to an image file\u00b6","text":""},{"location":"examples/attrs/#terminal-models","title":"Terminal Models\u00b6","text":"<p>If you have an enormous composition graph and want to chop it up, you can make that work by specifying models to be terminal nodes.</p> <p>For the CLI, use the <code>-t</code> option to specify a model to be a terminus. To specify more than one, used repeated <code>-t</code> options. So, for example, if you want one diagram rooted by <code>Party</code> that terminates at <code>Quest</code>, and another diagram that is rooted by <code>Quest</code>, you can use the following two shell commands.</p> <pre>erdantic erdantic.examples.attrs.Party \\ \n    -t erdantic erdantic.examples.attrs.Quest \\\n    -o party.png\nerdantic erdantic.examples.attrs.Quest -o quest.png\n</pre>"},{"location":"examples/dataclasses/","title":"Usage Example: dataclasses","text":"In\u00a0[1]: Copied! <pre>import inspect\nimport rich.syntax\n\nimport erdantic.examples.dataclasses\n\n\nrich.syntax.Syntax(\n    inspect.getsource(erdantic.examples.dataclasses), \n    \"python\",\n    theme=\"default\",\n    line_numbers=True\n)\n</pre> import inspect import rich.syntax  import erdantic.examples.dataclasses   rich.syntax.Syntax(     inspect.getsource(erdantic.examples.dataclasses),      \"python\",     theme=\"default\",     line_numbers=True ) Out[1]: <pre>   1 \"\"\"Example data model classes using standard library's                                                        \n   2 [`dataclasses`](https://docs.python.org/3/library/dataclasses.html) module.\"\"\"                                \n   3                                                                                                               \n   4 from dataclasses import dataclass, field                                                                      \n   5 from datetime import datetime                                                                                 \n   6 from enum import Enum                                                                                         \n   7 from typing import List, Optional                                                                             \n   8                                                                                                               \n   9                                                                                                               \n  10 class Alignment(str, Enum):                                                                                   \n  11     LAWFUL_GOOD = \"lawful_good\"                                                                               \n  12     NEUTRAL_GOOD = \"neutral_good\"                                                                             \n  13     CHAOTIC_GOOD = \"chaotic_good\"                                                                             \n  14     LAWFUL_NEUTRAL = \"lawful_neutral\"                                                                         \n  15     TRUE_NEUTRAL = \"true_neutral\"                                                                             \n  16     CHAOTIC_NEUTRAL = \"chaotic_neutral\"                                                                       \n  17     LAWFUL_EVIL = \"lawful_evil\"                                                                               \n  18     NEUTRAL_EVIL = \"neutral_evil\"                                                                             \n  19     CHAOTIC_EVIL = \"chaotic_evil\"                                                                             \n  20                                                                                                               \n  21                                                                                                               \n  22 @dataclass                                                                                                    \n  23 class Adventurer:                                                                                             \n  24     \"\"\"A person often late for dinner but with a tale or two to tell.                                         \n  25                                                                                                               \n  26     Attributes:                                                                                               \n  27         name (str): Name of this adventurer                                                                   \n  28         profession (str): Profession of this adventurer                                                       \n  29         alignment (Alignment): Alignment of this adventurer                                                   \n  30         level (int): Level of this adventurer                                                                 \n  31     \"\"\"                                                                                                       \n  32                                                                                                               \n  33     name: str                                                                                                 \n  34     profession: str                                                                                           \n  35     alignment: Alignment                                                                                      \n  36     level: int = 1                                                                                            \n  37                                                                                                               \n  38                                                                                                               \n  39 @dataclass                                                                                                    \n  40 class QuestGiver:                                                                                             \n  41     \"\"\"A person who offers a task that needs completing.                                                      \n  42                                                                                                               \n  43     Attributes:                                                                                               \n  44         name (str): Name of this quest giver                                                                  \n  45         faction (str): Faction that this quest giver belongs to                                               \n  46         location (str): Location this quest giver can be found                                                \n  47     \"\"\"                                                                                                       \n  48                                                                                                               \n  49     name: str                                                                                                 \n  50     faction: Optional[str] = None                                                                             \n  51     location: str = \"Adventurer's Guild\"                                                                      \n  52                                                                                                               \n  53                                                                                                               \n  54 @dataclass                                                                                                    \n  55 class Quest:                                                                                                  \n  56     \"\"\"A task to complete, with some monetary reward.                                                         \n  57                                                                                                               \n  58     Attributes:                                                                                               \n  59         name (str): Name by which this quest is referred to                                                   \n  60         giver (QuestGiver): Person who offered the quest                                                      \n  61         reward_gold (int): Amount of gold to be rewarded for quest completion                                 \n  62     \"\"\"                                                                                                       \n  63                                                                                                               \n  64     name: str                                                                                                 \n  65     giver: QuestGiver                                                                                         \n  66     reward_gold: int = 100                                                                                    \n  67                                                                                                               \n  68                                                                                                               \n  69 @dataclass                                                                                                    \n  70 class Party:                                                                                                  \n  71     \"\"\"A group of adventurers finding themselves doing and saying things altogether unexpected.               \n  72                                                                                                               \n  73     Attributes:                                                                                               \n  74         name (str): Name that party is known by                                                               \n  75         formed_datetime (datetime): Timestamp of when the party was formed                                    \n  76         members (List[Adventurer]): Adventurers that belong to this party                                     \n  77         active_quest (Optional[Quest]): Current quest that party is actively tackling                         \n  78     \"\"\"                                                                                                       \n  79                                                                                                               \n  80     name: str                                                                                                 \n  81     formed_datetime: datetime                                                                                 \n  82     members: List[Adventurer] = field(default_factory=list)                                                   \n  83     active_quest: Optional[Quest] = None                                                                      \n  84                                                                                                               \n</pre> In\u00a0[2]: Copied! <pre>!erdantic erdantic.examples.dataclasses.Party -o diagram.png\n</pre> !erdantic erdantic.examples.dataclasses.Party -o diagram.png <pre>2024-03-31 00:39:56,688 | erdantic.core | INFO | Adding model 'erdantic.examples.dataclasses.Party' to diagram...\r\n2024-03-31 00:39:56,690 | erdantic.core | INFO | Rendering diagram to diagram.png\r\n</pre> <pre>2024-03-31 00:39:56,734 | erdantic.cli | INFO | Rendered diagram to diagram.png\r\n</pre> <p>The format rendered is inferred from the file extension.</p> In\u00a0[3]: Copied! <pre>import erdantic as erd\nfrom erdantic.examples.dataclasses import Party\n\n\ndiagram = erd.create(Party)\ndiagram\n</pre> import erdantic as erd from erdantic.examples.dataclasses import Party   diagram = erd.create(Party) diagram <pre>EntityRelationshipDiagram(\n    models={\n        'erdantic.examples.dataclasses.Adventurer': ModelInfo(...),\n        'erdantic.examples.dataclasses.Party': ModelInfo(...),\n        'erdantic.examples.dataclasses.Quest': ModelInfo(...),\n        'erdantic.examples.dataclasses.QuestGiver': ModelInfo(...)\n    },\n    edges={\n        'erdantic.examples.dataclasses.Party-active_quest-erdantic.examples.dataclasses.Quest': Edge(...),\n        'erdantic.examples.dataclasses.Party-members-erdantic.examples.dataclasses.Adventurer': Edge(...),\n        'erdantic.examples.dataclasses.Quest-giver-erdantic.examples.dataclasses.QuestGiver': Edge(...)\n    }\n)\n</pre> Out[3]: <p>The <code>models</code> attribute gives you access to a dictionary of <code>ModelInfo</code> objects that contain the data for each model in the diagram. All of erdantic's data objects are Pydantic models.</p> <p>Tip</p> <p>     If you have the rich library installed, the IPython/Jupyter representation of erdantic's data objects will be nicely colored. </p> In\u00a0[4]: Copied! <pre>list(diagram.models.keys())\n</pre> list(diagram.models.keys()) Out[4]: <pre>['erdantic.examples.dataclasses.Adventurer',\n 'erdantic.examples.dataclasses.Party',\n 'erdantic.examples.dataclasses.Quest',\n 'erdantic.examples.dataclasses.QuestGiver']</pre> In\u00a0[5]: Copied! <pre>diagram.models['erdantic.examples.dataclasses.Party']\n</pre> diagram.models['erdantic.examples.dataclasses.Party'] <pre>ModelInfo(\n    full_name=FullyQualifiedName(module='erdantic.examples.dataclasses', qual_name='Party'),\n    name='Party',\n    fields={\n        'name': FieldInfo(\n            model_full_name=FullyQualifiedName(module='erdantic.examples.dataclasses', qual_name='Party'),\n            name='name',\n            type_name='str'\n        ),\n        'formed_datetime': FieldInfo(\n            model_full_name=FullyQualifiedName(module='erdantic.examples.dataclasses', qual_name='Party'),\n            name='formed_datetime',\n            type_name='datetime'\n        ),\n        'members': FieldInfo(\n            model_full_name=FullyQualifiedName(module='erdantic.examples.dataclasses', qual_name='Party'),\n            name='members',\n            type_name='List[Adventurer]'\n        ),\n        'active_quest': FieldInfo(\n            model_full_name=FullyQualifiedName(module='erdantic.examples.dataclasses', qual_name='Party'),\n            name='active_quest',\n            type_name='Optional[Quest]'\n        )\n    },\n    description='erdantic.examples.dataclasses.Party\\n\\nA group of adventurers finding themselves doing and saying \nthings altogether unexpected.\\n\\nAttributes:\\n    name (str): Name that party is known by\\n    formed_datetime \n(datetime): Timestamp of when the party was formed\\n    members (List[Adventurer]): Adventurers that belong to this\nparty\\n    active_quest (Optional[Quest]): Current quest that party is actively tackling\\n'\n)\n</pre> Out[5]: <pre></pre> <p>And the <code>edges</code> attribute gives you access to a dictionary of <code>Edge</code> objects that contain the data for each relationship between the models.</p> In\u00a0[6]: Copied! <pre>list(diagram.edges.keys())\n</pre> list(diagram.edges.keys()) Out[6]: <pre>['erdantic.examples.dataclasses.Party-active_quest-erdantic.examples.dataclasses.Quest',\n 'erdantic.examples.dataclasses.Party-members-erdantic.examples.dataclasses.Adventurer',\n 'erdantic.examples.dataclasses.Quest-giver-erdantic.examples.dataclasses.QuestGiver']</pre> In\u00a0[7]: Copied! <pre>diagram.edges[\"erdantic.examples.dataclasses.Party-members-erdantic.examples.dataclasses.Adventurer\"]\n</pre> diagram.edges[\"erdantic.examples.dataclasses.Party-members-erdantic.examples.dataclasses.Adventurer\"] <pre>Edge(\n    source_model_full_name=FullyQualifiedName(module='erdantic.examples.dataclasses', qual_name='Party'),\n    source_field_name='members',\n    target_model_full_name=FullyQualifiedName(module='erdantic.examples.dataclasses', qual_name='Adventurer'),\n    target_cardinality=&lt;Cardinality.MANY: 'many'&gt;,\n    target_modality=&lt;Modality.UNSPECIFIED: 'unspecified'&gt;,\n    source_cardinality=&lt;Cardinality.UNSPECIFIED: 'unspecified'&gt;,\n    source_modality=&lt;Modality.UNSPECIFIED: 'unspecified'&gt;\n)\n</pre> Out[7]: <pre></pre> <p>You can use the <code>draw</code> method to render the diagram to disk.</p> In\u00a0[8]: Copied! <pre>diagram.draw(\"diagram.svg\")\n\n# Equivalently, use erd.draw directly from Party\n# erd.draw(Party, out=\"dataclasses.svg\")\n</pre> diagram.draw(\"diagram.svg\")  # Equivalently, use erd.draw directly from Party # erd.draw(Party, out=\"dataclasses.svg\") <p>erdantic uses Graphviz, a well-established open-source C library, to create the diagram. Graphviz uses the DOT language for describing graphs. You use the <code>to_dot</code> method to get the DOT representation as a string.</p> In\u00a0[9]: Copied! <pre>print(diagram.to_dot())\n\n# Equivalently, use erd.to_dot directly from Party\nassert diagram.to_dot() == erd.to_dot(Party)\n</pre> print(diagram.to_dot())  # Equivalently, use erd.to_dot directly from Party assert diagram.to_dot() == erd.to_dot(Party) <pre>digraph \"Entity Relationship Diagram created by erdantic\" {\n\tgraph [fontcolor=gray66,\n\t\tfontname=\"Times New Roman,Times,Liberation Serif,serif\",\n\t\tfontsize=9,\n\t\tlabel=\"Created by erdantic v1.0.0rc1 &lt;https://github.com/drivendataorg/erdantic&gt;\",\n\t\tnodesep=0.5,\n\t\trankdir=LR,\n\t\tranksep=1.5\n\t];\n\tnode [fontname=\"Times New Roman,Times,Liberation Serif,serif\",\n\t\tfontsize=14,\n\t\tlabel=\"\\N\",\n\t\tshape=plain\n\t];\n\tedge [dir=both];\n\t\"erdantic.examples.dataclasses.Adventurer\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;Adventurer&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;profession&lt;/td&gt;&lt;td port=\"profession\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;alignment&lt;/td&gt;&lt;td port=\"alignment\"&gt;Alignment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;level&lt;/td&gt;&lt;td port=\"level\"&gt;int&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.dataclasses.Adventurer&amp;#xA;&amp;#xA;A person often late for dinner but with a tale or two to tell.&amp;#xA;&amp;#xA;Attributes:&amp;#\\\nxA;    name (str): Name of this adventurer&amp;#xA;    profession (str): Profession of this adventurer&amp;#xA;    alignment (Alignment): \\\nAlignment of this adventurer&amp;#xA;    level (int): Level of this adventurer&amp;#xA;\"];\n\t\"erdantic.examples.dataclasses.Party\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;Party&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;formed_datetime&lt;/td&gt;&lt;td port=\"formed_datetime\"&gt;datetime&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;members&lt;/td&gt;&lt;td port=\"members\"&gt;List[Adventurer]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;active_quest&lt;/td&gt;&lt;td port=\"active_quest\"&gt;Optional[Quest]&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.dataclasses.Party&amp;#xA;&amp;#xA;A group of adventurers finding themselves doing and saying things altogether unexpected.&amp;#\\\nxA;&amp;#xA;Attributes:&amp;#xA;    name (str): Name that party is known by&amp;#xA;    formed_datetime (datetime): Timestamp of when the party \\\nwas formed&amp;#xA;    members (List[Adventurer]): Adventurers that belong to this party&amp;#xA;    active_quest (Optional[Quest]): Current \\\nquest that party is actively tackling&amp;#xA;\"];\n\t\"erdantic.examples.dataclasses.Party\":members:e -&gt; \"erdantic.examples.dataclasses.Adventurer\":_root:w\t[arrowhead=crownone,\n\t\tarrowtail=nonenone];\n\t\"erdantic.examples.dataclasses.Quest\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;Quest&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;giver&lt;/td&gt;&lt;td port=\"giver\"&gt;QuestGiver&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;reward_gold&lt;/td&gt;&lt;td port=\"reward_gold\"&gt;int&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.dataclasses.Quest&amp;#xA;&amp;#xA;A task to complete, with some monetary reward.&amp;#xA;&amp;#xA;Attributes:&amp;#xA;    name (str): \\\nName by which this quest is referred to&amp;#xA;    giver (QuestGiver): Person who offered the quest&amp;#xA;    reward_gold (int): Amount \\\nof gold to be rewarded for quest completion&amp;#xA;\"];\n\t\"erdantic.examples.dataclasses.Party\":active_quest:e -&gt; \"erdantic.examples.dataclasses.Quest\":_root:w\t[arrowhead=noneteeodot,\n\t\tarrowtail=nonenone];\n\t\"erdantic.examples.dataclasses.QuestGiver\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;QuestGiver&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;faction&lt;/td&gt;&lt;td port=\"faction\"&gt;Optional[str]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;location&lt;/td&gt;&lt;td port=\"location\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.dataclasses.QuestGiver&amp;#xA;&amp;#xA;A person who offers a task that needs completing.&amp;#xA;&amp;#xA;Attributes:&amp;#xA;    \\\nname (str): Name of this quest giver&amp;#xA;    faction (str): Faction that this quest giver belongs to&amp;#xA;    location (str): Location \\\nthis quest giver can be found&amp;#xA;\"];\n\t\"erdantic.examples.dataclasses.Quest\":giver:e -&gt; \"erdantic.examples.dataclasses.QuestGiver\":_root:w\t[arrowhead=noneteetee,\n\t\tarrowtail=nonenone];\n}\n\n</pre> <p>When using the Python library, pass your terminal node in a list to the <code>terminal_models</code> keyword argument. Below is the Python code for creating diagrams equivalent to the above shell commands.</p> In\u00a0[10]: Copied! <pre>from erdantic.examples.dataclasses import Quest\n\ndiagram1 = erd.create(Party, terminal_models=[Quest])\ndiagram1\n</pre> from erdantic.examples.dataclasses import Quest  diagram1 = erd.create(Party, terminal_models=[Quest]) diagram1 <pre>EntityRelationshipDiagram(\n    models={\n        'erdantic.examples.dataclasses.Adventurer': ModelInfo(...),\n        'erdantic.examples.dataclasses.Party': ModelInfo(...),\n        'erdantic.examples.dataclasses.Quest': ModelInfo(...)\n    },\n    edges={\n        'erdantic.examples.dataclasses.Party-active_quest-erdantic.examples.dataclasses.Quest': Edge(...),\n        'erdantic.examples.dataclasses.Party-members-erdantic.examples.dataclasses.Adventurer': Edge(...)\n    }\n)\n</pre> Out[10]: In\u00a0[11]: Copied! <pre>diagram2 = erd.create(Quest)\ndiagram2\n</pre> diagram2 = erd.create(Quest) diagram2 <pre>EntityRelationshipDiagram(\n    models={\n        'erdantic.examples.dataclasses.Quest': ModelInfo(...),\n        'erdantic.examples.dataclasses.QuestGiver': ModelInfo(...)\n    },\n    edges={'erdantic.examples.dataclasses.Quest-giver-erdantic.examples.dataclasses.QuestGiver': Edge(...)}\n)\n</pre> Out[11]:"},{"location":"examples/dataclasses/#usage-example-dataclasses","title":"Usage Example: dataclasses\u00b6","text":"<p>This notebook shows an example of using erdantic with the standard library's dataclasses module.</p> <p>Let's take a look at the dataclasses (from here on in referred to as \"models\") from the <code>erdantic.examples.dataclasses</code> module. Here's their source code for clarity.</p>"},{"location":"examples/dataclasses/#using-the-cli","title":"Using the CLI\u00b6","text":"<p>The fastest way to rendering a diagram is to use the command-line interface. Below we use IPython's <code>!</code> to run a command in the system shell. We pass the full dotted path to the root class of our composition hierarchy, along with an output file path. erdantic will walk the composition graph to find all child classes.</p>"},{"location":"examples/dataclasses/#using-the-python-library","title":"Using the Python library\u00b6","text":"<p>You can also use the erdantic Python library, which lets you inspect the diagram object. The diagram object contains all of the data that erdantic extracted about the model you provide, as well as any related models. As demonstrated below, the diagram object automatically pretty-prints in IPython or Jupyter notebooks and even automatically renders in Jupyter notebooks.</p>"},{"location":"examples/dataclasses/#inspecting-the-data","title":"Inspecting the data\u00b6","text":""},{"location":"examples/dataclasses/#rendering-the-diagram-to-an-image-file","title":"Rendering the diagram to an image file\u00b6","text":""},{"location":"examples/dataclasses/#terminal-models","title":"Terminal Models\u00b6","text":"<p>If you have an enormous composition graph and want to chop it up, you can make that work by specifying models to be terminal nodes.</p> <p>For the CLI, use the <code>-t</code> option to specify a model to be a terminus. To specify more than one, used repeated <code>-t</code> options. So, for example, if you want one diagram rooted by <code>Party</code> that terminates at <code>Quest</code>, and another diagram that is rooted by <code>Quest</code>, you can use the following two shell commands.</p> <pre>erdantic erdantic.examples.dataclasses.Party \\ \n    -t erdantic erdantic.examples.dataclasses.Quest \\\n    -o party.png\nerdantic erdantic.examples.dataclasses.Quest -o quest.png\n</pre>"},{"location":"examples/pydantic/","title":"Usage Example: Pydantic","text":"In\u00a0[1]: Copied! <pre>import inspect\nimport rich.syntax\n\nimport erdantic.examples.pydantic\n\n\nrich.syntax.Syntax(\n    inspect.getsource(erdantic.examples.pydantic), \n    \"python\",\n    theme=\"default\",\n    line_numbers=True\n)\n</pre> import inspect import rich.syntax  import erdantic.examples.pydantic   rich.syntax.Syntax(     inspect.getsource(erdantic.examples.pydantic),      \"python\",     theme=\"default\",     line_numbers=True ) Out[1]: <pre>   1 \"\"\"Example data model classes using [Pydantic](https://pydantic-docs.helpmanual.io/).\"\"\"                      \n   2                                                                                                               \n   3 from datetime import datetime                                                                                 \n   4 from enum import Enum                                                                                         \n   5 from typing import List, Optional                                                                             \n   6                                                                                                               \n   7 from pydantic import BaseModel                                                                                \n   8                                                                                                               \n   9                                                                                                               \n  10 class Alignment(str, Enum):                                                                                   \n  11     LAWFUL_GOOD = \"lawful_good\"                                                                               \n  12     NEUTRAL_GOOD = \"neutral_good\"                                                                             \n  13     CHAOTIC_GOOD = \"chaotic_good\"                                                                             \n  14     LAWFUL_NEUTRAL = \"lawful_neutral\"                                                                         \n  15     TRUE_NEUTRAL = \"true_neutral\"                                                                             \n  16     CHAOTIC_NEUTRAL = \"chaotic_neutral\"                                                                       \n  17     LAWFUL_EVIL = \"lawful_evil\"                                                                               \n  18     NEUTRAL_EVIL = \"neutral_evil\"                                                                             \n  19     CHAOTIC_EVIL = \"chaotic_evil\"                                                                             \n  20                                                                                                               \n  21                                                                                                               \n  22 class Adventurer(BaseModel):                                                                                  \n  23     \"\"\"A person often late for dinner but with a tale or two to tell.                                         \n  24                                                                                                               \n  25     Attributes:                                                                                               \n  26         name (str): Name of this adventurer                                                                   \n  27         profession (str): Profession of this adventurer                                                       \n  28         alignment (Alignment): Alignment of this adventurer                                                   \n  29         level (int): Level of this adventurer                                                                 \n  30     \"\"\"                                                                                                       \n  31                                                                                                               \n  32     name: str                                                                                                 \n  33     profession: str                                                                                           \n  34     alignment: Alignment                                                                                      \n  35     level: int = 1                                                                                            \n  36                                                                                                               \n  37                                                                                                               \n  38 class QuestGiver(BaseModel):                                                                                  \n  39     \"\"\"A person who offers a task that needs completing.                                                      \n  40                                                                                                               \n  41     Attributes:                                                                                               \n  42         name (str): Name of this quest giver                                                                  \n  43         faction (str): Faction that this quest giver belongs to                                               \n  44         location (str): Location this quest giver can be found                                                \n  45     \"\"\"                                                                                                       \n  46                                                                                                               \n  47     name: str                                                                                                 \n  48     faction: Optional[str] = None                                                                             \n  49     location: str = \"Adventurer's Guild\"                                                                      \n  50                                                                                                               \n  51                                                                                                               \n  52 class Quest(BaseModel):                                                                                       \n  53     \"\"\"A task to complete, with some monetary reward.                                                         \n  54                                                                                                               \n  55     Attributes:                                                                                               \n  56         name (str): Name by which this quest is referred to                                                   \n  57         giver (QuestGiver): Person who offered the quest                                                      \n  58         reward_gold (int): Amount of gold to be rewarded for quest completion                                 \n  59     \"\"\"                                                                                                       \n  60                                                                                                               \n  61     name: str                                                                                                 \n  62     giver: QuestGiver                                                                                         \n  63     reward_gold: int = 100                                                                                    \n  64                                                                                                               \n  65                                                                                                               \n  66 class Party(BaseModel):                                                                                       \n  67     \"\"\"A group of adventurers finding themselves doing and saying things altogether unexpected.               \n  68                                                                                                               \n  69     Attributes:                                                                                               \n  70         name (str): Name that party is known by                                                               \n  71         formed_datetime (datetime): Timestamp of when the party was formed                                    \n  72         members (List[Adventurer]): Adventurers that belong to this party                                     \n  73         active_quest (Optional[Quest]): Current quest that party is actively tackling                         \n  74     \"\"\"                                                                                                       \n  75                                                                                                               \n  76     name: str                                                                                                 \n  77     formed_datetime: datetime                                                                                 \n  78     members: List[Adventurer] = []                                                                            \n  79     active_quest: Optional[Quest] = None                                                                      \n  80                                                                                                               \n</pre> In\u00a0[2]: Copied! <pre>!erdantic erdantic.examples.pydantic.Party -o diagram.png\n</pre> !erdantic erdantic.examples.pydantic.Party -o diagram.png <pre>2024-03-31 00:39:58,842 | erdantic.core | INFO | Adding model 'erdantic.examples.pydantic.Party' to diagram...\r\n2024-03-31 00:39:58,844 | erdantic.core | INFO | Rendering diagram to diagram.png\r\n</pre> <pre>2024-03-31 00:39:58,885 | erdantic.cli | INFO | Rendered diagram to diagram.png\r\n</pre> <p>The format rendered is inferred from the file extension.</p> In\u00a0[3]: Copied! <pre>import erdantic as erd\nfrom erdantic.examples.pydantic import Party\n\n\ndiagram = erd.create(Party)\ndiagram\n</pre> import erdantic as erd from erdantic.examples.pydantic import Party   diagram = erd.create(Party) diagram <pre>EntityRelationshipDiagram(\n    models={\n        'erdantic.examples.pydantic.Adventurer': ModelInfo(...),\n        'erdantic.examples.pydantic.Party': ModelInfo(...),\n        'erdantic.examples.pydantic.Quest': ModelInfo(...),\n        'erdantic.examples.pydantic.QuestGiver': ModelInfo(...)\n    },\n    edges={\n        'erdantic.examples.pydantic.Party-active_quest-erdantic.examples.pydantic.Quest': Edge(...),\n        'erdantic.examples.pydantic.Party-members-erdantic.examples.pydantic.Adventurer': Edge(...),\n        'erdantic.examples.pydantic.Quest-giver-erdantic.examples.pydantic.QuestGiver': Edge(...)\n    }\n)\n</pre> Out[3]: <p>The <code>models</code> attribute gives you access to a dictionary of <code>ModelInfo</code> objects that contain the data for each model in the diagram. All of erdantic's data objects are Pydantic models.</p> <p>Tip</p> <p>     If you have the rich library installed, the IPython/Jupyter representation of erdantic's data objects will be nicely colored. </p> In\u00a0[4]: Copied! <pre>list(diagram.models.keys())\n</pre> list(diagram.models.keys()) Out[4]: <pre>['erdantic.examples.pydantic.Adventurer',\n 'erdantic.examples.pydantic.Party',\n 'erdantic.examples.pydantic.Quest',\n 'erdantic.examples.pydantic.QuestGiver']</pre> In\u00a0[5]: Copied! <pre>diagram.models['erdantic.examples.pydantic.Party']\n</pre> diagram.models['erdantic.examples.pydantic.Party'] <pre>ModelInfo(\n    full_name=FullyQualifiedName(module='erdantic.examples.pydantic', qual_name='Party'),\n    name='Party',\n    fields={\n        'name': FieldInfo(\n            model_full_name=FullyQualifiedName(module='erdantic.examples.pydantic', qual_name='Party'),\n            name='name',\n            type_name='str'\n        ),\n        'formed_datetime': FieldInfo(\n            model_full_name=FullyQualifiedName(module='erdantic.examples.pydantic', qual_name='Party'),\n            name='formed_datetime',\n            type_name='datetime'\n        ),\n        'members': FieldInfo(\n            model_full_name=FullyQualifiedName(module='erdantic.examples.pydantic', qual_name='Party'),\n            name='members',\n            type_name='List[Adventurer]'\n        ),\n        'active_quest': FieldInfo(\n            model_full_name=FullyQualifiedName(module='erdantic.examples.pydantic', qual_name='Party'),\n            name='active_quest',\n            type_name='Optional[Quest]'\n        )\n    },\n    description='erdantic.examples.pydantic.Party\\n\\nA group of adventurers finding themselves doing and saying \nthings altogether unexpected.\\n\\nAttributes:\\n    name (str): Name that party is known by\\n    formed_datetime \n(datetime): Timestamp of when the party was formed\\n    members (List[Adventurer]): Adventurers that belong to this\nparty\\n    active_quest (Optional[Quest]): Current quest that party is actively tackling\\n'\n)\n</pre> Out[5]: <pre></pre> <p>And the <code>edges</code> attribute gives you access to a dictionary of <code>Edge</code> objects that contain the data for each relationship between the models.</p> In\u00a0[6]: Copied! <pre>list(diagram.edges.keys())\n</pre> list(diagram.edges.keys()) Out[6]: <pre>['erdantic.examples.pydantic.Party-active_quest-erdantic.examples.pydantic.Quest',\n 'erdantic.examples.pydantic.Party-members-erdantic.examples.pydantic.Adventurer',\n 'erdantic.examples.pydantic.Quest-giver-erdantic.examples.pydantic.QuestGiver']</pre> In\u00a0[7]: Copied! <pre>diagram.edges[\"erdantic.examples.pydantic.Party-members-erdantic.examples.pydantic.Adventurer\"]\n</pre> diagram.edges[\"erdantic.examples.pydantic.Party-members-erdantic.examples.pydantic.Adventurer\"] <pre>Edge(\n    source_model_full_name=FullyQualifiedName(module='erdantic.examples.pydantic', qual_name='Party'),\n    source_field_name='members',\n    target_model_full_name=FullyQualifiedName(module='erdantic.examples.pydantic', qual_name='Adventurer'),\n    target_cardinality=&lt;Cardinality.MANY: 'many'&gt;,\n    target_modality=&lt;Modality.UNSPECIFIED: 'unspecified'&gt;,\n    source_cardinality=&lt;Cardinality.UNSPECIFIED: 'unspecified'&gt;,\n    source_modality=&lt;Modality.UNSPECIFIED: 'unspecified'&gt;\n)\n</pre> Out[7]: <pre></pre> <p>You can use the <code>draw</code> method to render the diagram to disk.</p> In\u00a0[8]: Copied! <pre>diagram.draw(\"diagram.svg\")\n\n# Equivalently, use erd.draw directly from Party\n# erd.draw(Party, out=\"diagram.svg\")\n</pre> diagram.draw(\"diagram.svg\")  # Equivalently, use erd.draw directly from Party # erd.draw(Party, out=\"diagram.svg\") <p>erdantic uses Graphviz, a well-established open-source C library, to create the diagram. Graphviz uses the DOT language for describing graphs. You use the <code>to_dot</code> method to get the DOT representation as a string.</p> In\u00a0[9]: Copied! <pre>print(diagram.to_dot())\n\n# Equivalently, use erd.to_dot directly from Party\nassert diagram.to_dot() == erd.to_dot(Party)\n</pre> print(diagram.to_dot())  # Equivalently, use erd.to_dot directly from Party assert diagram.to_dot() == erd.to_dot(Party) <pre>digraph \"Entity Relationship Diagram created by erdantic\" {\n\tgraph [fontcolor=gray66,\n\t\tfontname=\"Times New Roman,Times,Liberation Serif,serif\",\n\t\tfontsize=9,\n\t\tlabel=\"Created by erdantic v1.0.0rc1 &lt;https://github.com/drivendataorg/erdantic&gt;\",\n\t\tnodesep=0.5,\n\t\trankdir=LR,\n\t\tranksep=1.5\n\t];\n\tnode [fontname=\"Times New Roman,Times,Liberation Serif,serif\",\n\t\tfontsize=14,\n\t\tlabel=\"\\N\",\n\t\tshape=plain\n\t];\n\tedge [dir=both];\n\t\"erdantic.examples.pydantic.Adventurer\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;Adventurer&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;profession&lt;/td&gt;&lt;td port=\"profession\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;alignment&lt;/td&gt;&lt;td port=\"alignment\"&gt;Alignment&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;level&lt;/td&gt;&lt;td port=\"level\"&gt;int&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.pydantic.Adventurer&amp;#xA;&amp;#xA;A person often late for dinner but with a tale or two to tell.&amp;#xA;&amp;#xA;Attributes:&amp;#\\\nxA;    name (str): Name of this adventurer&amp;#xA;    profession (str): Profession of this adventurer&amp;#xA;    alignment (Alignment): \\\nAlignment of this adventurer&amp;#xA;    level (int): Level of this adventurer&amp;#xA;\"];\n\t\"erdantic.examples.pydantic.Party\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;Party&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;formed_datetime&lt;/td&gt;&lt;td port=\"formed_datetime\"&gt;datetime&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;members&lt;/td&gt;&lt;td port=\"members\"&gt;List[Adventurer]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;active_quest&lt;/td&gt;&lt;td port=\"active_quest\"&gt;Optional[Quest]&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.pydantic.Party&amp;#xA;&amp;#xA;A group of adventurers finding themselves doing and saying things altogether unexpected.&amp;#\\\nxA;&amp;#xA;Attributes:&amp;#xA;    name (str): Name that party is known by&amp;#xA;    formed_datetime (datetime): Timestamp of when the party \\\nwas formed&amp;#xA;    members (List[Adventurer]): Adventurers that belong to this party&amp;#xA;    active_quest (Optional[Quest]): Current \\\nquest that party is actively tackling&amp;#xA;\"];\n\t\"erdantic.examples.pydantic.Party\":members:e -&gt; \"erdantic.examples.pydantic.Adventurer\":_root:w\t[arrowhead=crownone,\n\t\tarrowtail=nonenone];\n\t\"erdantic.examples.pydantic.Quest\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;Quest&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;giver&lt;/td&gt;&lt;td port=\"giver\"&gt;QuestGiver&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;reward_gold&lt;/td&gt;&lt;td port=\"reward_gold\"&gt;int&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.pydantic.Quest&amp;#xA;&amp;#xA;A task to complete, with some monetary reward.&amp;#xA;&amp;#xA;Attributes:&amp;#xA;    name (str): \\\nName by which this quest is referred to&amp;#xA;    giver (QuestGiver): Person who offered the quest&amp;#xA;    reward_gold (int): Amount \\\nof gold to be rewarded for quest completion&amp;#xA;\"];\n\t\"erdantic.examples.pydantic.Party\":active_quest:e -&gt; \"erdantic.examples.pydantic.Quest\":_root:w\t[arrowhead=noneteeodot,\n\t\tarrowtail=nonenone];\n\t\"erdantic.examples.pydantic.QuestGiver\"\t[label=&lt;&lt;table border=\"0\" cellborder=\"1\" cellspacing=\"0\"&gt;&lt;tr&gt;&lt;td port=\"_root\" colspan=\"2\"&gt;&lt;b&gt;QuestGiver&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td port=\"name\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;faction&lt;/td&gt;&lt;td port=\"faction\"&gt;Optional[str]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;location&lt;/td&gt;&lt;td port=\"location\"&gt;str&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&gt;,\n\t\ttooltip=\"erdantic.examples.pydantic.QuestGiver&amp;#xA;&amp;#xA;A person who offers a task that needs completing.&amp;#xA;&amp;#xA;Attributes:&amp;#xA;    name (\\\nstr): Name of this quest giver&amp;#xA;    faction (str): Faction that this quest giver belongs to&amp;#xA;    location (str): Location \\\nthis quest giver can be found&amp;#xA;\"];\n\t\"erdantic.examples.pydantic.Quest\":giver:e -&gt; \"erdantic.examples.pydantic.QuestGiver\":_root:w\t[arrowhead=noneteetee,\n\t\tarrowtail=nonenone];\n}\n\n</pre> <p>When using the Python library, pass your terminal node in a list to the <code>terminal_models</code> keyword argument. Below is the Python code for creating diagrams equivalent to the above shell commands.</p> In\u00a0[10]: Copied! <pre>from erdantic.examples.pydantic import Quest\n\ndiagram1 = erd.create(Party, terminal_models=[Quest])\ndiagram1\n</pre> from erdantic.examples.pydantic import Quest  diagram1 = erd.create(Party, terminal_models=[Quest]) diagram1 <pre>EntityRelationshipDiagram(\n    models={\n        'erdantic.examples.pydantic.Adventurer': ModelInfo(...),\n        'erdantic.examples.pydantic.Party': ModelInfo(...),\n        'erdantic.examples.pydantic.Quest': ModelInfo(...)\n    },\n    edges={\n        'erdantic.examples.pydantic.Party-active_quest-erdantic.examples.pydantic.Quest': Edge(...),\n        'erdantic.examples.pydantic.Party-members-erdantic.examples.pydantic.Adventurer': Edge(...)\n    }\n)\n</pre> Out[10]: In\u00a0[11]: Copied! <pre>diagram2 = erd.create(Quest)\ndiagram2\n</pre> diagram2 = erd.create(Quest) diagram2 <pre>EntityRelationshipDiagram(\n    models={\n        'erdantic.examples.pydantic.Quest': ModelInfo(...),\n        'erdantic.examples.pydantic.QuestGiver': ModelInfo(...)\n    },\n    edges={'erdantic.examples.pydantic.Quest-giver-erdantic.examples.pydantic.QuestGiver': Edge(...)}\n)\n</pre> Out[11]:"},{"location":"examples/pydantic/#usage-example-pydantic","title":"Usage Example: Pydantic\u00b6","text":"<p>This notebook shows an example of using erdantic with Pydantic models.</p> <p>Let's take a look at the models from the <code>erdantic.examples.pydantic</code> module. Here's their source code for clarity.</p>"},{"location":"examples/pydantic/#using-the-cli","title":"Using the CLI\u00b6","text":"<p>The fastest way to rendering a diagram is to use the command-line interface. Below we use IPython's <code>!</code> to run a command in the system shell. We pass the full dotted path to the root class of our composition hierarchy, along with an output file path. erdantic will walk the composition graph to find all child classes.</p>"},{"location":"examples/pydantic/#using-the-python-library","title":"Using the Python library\u00b6","text":"<p>You can also use the erdantic Python library, which lets you inspect the diagram object. The diagram object contains all of the data that erdantic extracted about the model you provide, as well as any related models. As demonstrated below, the diagram object automatically pretty-prints in IPython or Jupyter notebooks and even automatically renders in Jupyter notebooks.</p>"},{"location":"examples/pydantic/#inspecting-the-data","title":"Inspecting the data\u00b6","text":""},{"location":"examples/pydantic/#rendering-the-diagram-to-an-image-file","title":"Rendering the diagram to an image file\u00b6","text":""},{"location":"examples/pydantic/#terminal-models","title":"Terminal Models\u00b6","text":"<p>If you have an enormous composition graph and want to chop it up, you can make that work by specifying models to be terminal nodes.</p> <p>For the CLI, use the <code>-t</code> option to specify a model to be a terminus. To specify more than one, used repeated <code>-t</code> options. So, for example, if you want one diagram rooted by <code>Party</code> that terminates at <code>Quest</code>, and another diagram that is rooted by <code>Quest</code>, you can use the following two shell commands.</p> <pre>erdantic erdantic.examples.pydantic.Party \\ \n    -t erdantic erdantic.examples.pydantic.Quest \\\n    -o party.png\nerdantic erdantic.examples.pydantic.Quest -o quest.png\n</pre>"}]}